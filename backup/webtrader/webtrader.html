<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebTrader - Professional Trading Platform</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='stylesheets/style.css') }}">
    <style>
        :root {
            --primary-color: #0d6efd;
            --dark-bg: #0e1525;
            --darker-bg: #0b101e;
            --medium-bg: #1a2033;
            --light-bg: #232a3d;
            --text-color: #e0e0e0;
            --secondary-text: #8a8fa4;
            --success-color: #22c55e;
            --danger-color: #ef4444;
            --border-color: #2d3446;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--dark-bg);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        
        .trading-platform {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
        }
        
        /* Main content styles */
        .content-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* Instruments list styles */
        .instruments-list {
            width: 300px;
            background-color: var(--medium-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .instruments-header {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .instruments-header h5 {
            margin: 0;
            font-size: 1rem;
        }
        
        /* Market filter buttons */
        .market-filter-buttons {
            display: flex;
            flex-wrap: wrap;
            padding: 10px;
            gap: 5px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .market-filter-btn {
            flex: 1;
            min-width: 70px;
            padding: 8px 10px;
            background-color: var(--darker-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--secondary-text);
            font-size: 0.8rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .market-filter-btn i {
            margin-right: 5px;
        }
        
        .market-filter-btn:hover {
            background-color: var(--light-bg);
            color: var(--text-color);
        }
        
        .market-filter-btn.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .instruments-table {
            width: 100%;
        }
        
        .instruments-table th {
            background-color: var(--darker-bg);
            color: var(--secondary-text);
            font-weight: 500;
            font-size: 0.8rem;
            padding: 10px 15px;
            text-align: left;
            position: sticky;
            top: 0;
        }
        
        .instruments-table td {
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
        }
        
        .instruments-table tr:hover {
            background-color: var(--light-bg);
            cursor: pointer;
        }
        
        .price-change {
            display: flex;
            align-items: center;
        }
        
        .price-change i {
            margin-right: 5px;
        }
        
        /* Chart area */
        .chart-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            background-color: var(--dark-bg);
        }
        
        .chart-header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }
        
        .current-symbol {
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .chart-container {
            flex: 1;
            width: 100%;
            position: relative;
        }
        
        /* Trading form */
        .trading-panel {
            padding: 15px;
            background-color: var(--medium-bg);
            border-top: 1px solid var(--border-color);
        }
        
        .trading-form {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .form-group {
            flex: 1;
            min-width: 120px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.8rem;
            color: var(--secondary-text);
        }
        
        .form-control {
            width: 100%;
            padding: 8px 12px;
            background-color: var(--darker-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-color);
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .btn-sell {
            background-color: var(--danger-color);
            color: white;
        }
        
        .btn-buy {
            background-color: var(--success-color);
            color: white;
        }
        
        /* Order book and trades */
        .trades-section {
            padding: 20px;
        }
        
        .section-title {
            margin-bottom: 15px;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .table-responsive {
            overflow-x: auto;
        }
        
        .trades-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .trades-table th {
            background-color: var(--medium-bg);
            color: var(--secondary-text);
            font-weight: 500;
            padding: 12px 15px;
            text-align: left;
            font-size: 0.9rem;
        }
        
        .trades-table td {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .trades-table tr:hover {
            background-color: var(--light-bg);
        }
        
        .badge {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .badge-buy {
            background-color: rgba(34, 197, 94, 0.2);
            color: var(--success-color);
        }
        
        .badge-sell {
            background-color: rgba(239, 68, 68, 0.2);
            color: var(--danger-color);
        }
        
        .badge-pending {
            background-color: rgba(234, 179, 8, 0.2);
            color: #eab308;
        }
        
        .account-info {
            display: flex;
            align-items: center;
            margin-left: 20px;
        }
        
        .account-balance {
            background-color: var(--medium-bg);
            padding: 5px 12px;
            border-radius: 5px;
            margin-right: 10px;
            font-size: 0.9rem;
        }
        
        .account-label {
            color: var(--secondary-text);
            margin-right: 5px;
            font-size: 0.8rem;
        }
        
        .account-value {
            font-weight: 600;
        }
        
        /* Responsive adjustments */
        @media (max-width: 992px) {
            .instruments-list {
                width: 250px;
            }
            
            .trading-panel-pro {
                width: 250px;
            }
            
            .balance-info {
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .balance-item {
                padding: 5px;
            }
        }
        
        @media (max-width: 768px) {
            .content-wrapper {
                flex-direction: column;
            }
            
            .instruments-list {
                width: 100%;
                height: auto;
                max-height: 300px;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }
            
            .chart-area {
                height: 0;
                flex: 1;
            }
            
            .trading-panel-pro {
                width: 100%;
            }
            
            .trades-section {
                overflow-x: auto;
            }
            
            .user-info {
                flex-wrap: wrap;
                justify-content: flex-end;
                gap: 10px;
            }
            
            .balance-info {
                order: 1;
                width: 100%;
                margin-top: 10px;
                justify-content: space-around;
            }
            
            .username {
                order: 2;
                border-left: none;
                border-top: 1px solid var(--border-color);
                padding-top: 5px;
            }
            
            .header-buttons {
                order: 3;
                width: 100%;
                justify-content: space-between;
                margin-top: 10px;
            }
            
            .return-admin-btn, .logout-btn {
                flex: 1;
                justify-content: center;
            }
        }
        
        @media (max-width: 576px) {
            .header {
                flex-direction: column;
                padding: 10px;
                gap: 15px;
                align-items: flex-start;
            }
            
            .logo {
                margin-bottom: 5px;
                align-self: center;
            }
            
            .user-info {
                width: 100%;
            }
            
            .balance-info {
                width: 100%;
                padding: 5px;
                justify-content: space-between;
            }
            
            .balance-item {
                padding: 2px;
            }
            
            .market-filter-buttons {
                justify-content: space-between;
            }
            
            .market-filter-btn {
                min-width: auto;
                padding: 5px 8px;
                font-size: 0.7rem;
            }
            
            .market-filter-btn i {
                margin-right: 2px;
            }
            
            .trades-section .section-title {
                font-size: 1rem;
            }
            
            .header-buttons {
                flex-direction: column;
                width: 100%;
            }
            
            .return-admin-btn, .logout-btn {
                width: 100%;
                justify-content: center;
                margin-top: 5px;
                padding: 10px;
            }
        }
        
        /* Scoped styles for WebTrader Layout */
        html, body {
             height: 100%;
             overflow: hidden; /* Prevent double scrollbars */
        }
        body {
            display: flex;
            flex-direction: column; /* Ensure body uses flex column */
        }
        .app-container {
            display: flex;
            flex-direction: row; /* Sidebar next to content */
            flex-grow: 1; /* Allow container to grow */
            height: 100vh; /* Ensure full viewport height */
            overflow: hidden;
        }
        .app-sidebar { 
            /* Assuming sidebar has fixed width and height handled by its own CSS */
            flex-shrink: 0; 
        }
        .app-content {
            display: flex;
            flex-direction: column; /* Header above content-wrapper */
            flex-grow: 1;
            overflow: hidden; 
            height: 100%;
        }
        .market-data {
             flex-shrink: 0; /* Prevent market data bar from shrinking */
        }
        .content-wrapper {
            display: flex;
            flex-grow: 1; /* Takes remaining vertical space */
            overflow: hidden; /* Important to contain children */
            height: 100%; /* Make wrapper take full height within app-content */
        }
        
        /* Ensure child columns also respect height */
        .instruments-list, .chart-area, .trading-panel-pro {
             height: 100%; /* Make columns take full height of wrapper */
             display: flex; /* Use flex for vertical layout inside */
             flex-direction: column;
             overflow-y: auto; /* Allow internal scrolling if needed */
        }
        
        /* Override overflow for chart-area to manage internal scrolling */
        .chart-area {
             overflow: hidden;
        }
        .trades-section {
             overflow-y: auto; /* Scroll trades */
             flex-shrink: 0; /* Prevent shrinking */
        }
        
        /* Responsive overrides */
        @media (max-width: 992px) {
            .app-container {
                 flex-direction: column;
                 height: auto; /* Allow height to be determined by content */
                 overflow: visible;
            }
            .app-content {
                 height: auto;
                 overflow: visible;
            }
            .content-wrapper {
                flex-direction: column;
                height: auto; 
                overflow: visible;
            }
            .instruments-list,
            .trading-panel-pro,
            .chart-area {
                height: auto;
                overflow: visible;
            }
            .trades-section {
                overflow-y: visible;
            }
        }
        /* --- End Scoped Styles --- */
        
        /* Modern Trading Panel Styles */
        .trading-panel-pro {
            width: 300px;
            background-color: var(--darker-bg);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 0;
            overflow-y: auto;
        }
        
        .trade-header {
            padding: 15px;
            background-color: var(--medium-bg);
            border-bottom: 1px solid var(--border-color);
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .trading-form-pro {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .price-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 5px;
        }
        
        .btn-price {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 15px 10px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: var(--medium-bg);
        }
        
        .btn-price span {
            font-size: 0.85rem;
            margin-bottom: 5px;
        }
        
        .btn-price strong {
            font-size: 1.2rem;
        }
        
        .btn-sell-price {
            color: var(--danger-color);
            border-left: 3px solid var(--danger-color);
        }
        
        .btn-sell-price.active {
            background-color: rgba(239, 68, 68, 0.15);
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.3);
        }
        
        .btn-buy-price {
            color: var(--success-color);
            border-left: 3px solid var(--success-color);
        }
        
        .btn-buy-price.active {
            background-color: rgba(34, 197, 94, 0.15);
            box-shadow: 0 0 8px rgba(34, 197, 94, 0.3);
        }
        
        .form-row {
            display: flex;
            gap: 10px;
        }
        
        .amount-group {
            position: relative;
            width: 100%;
        }
        
        .amount-group input {
            padding-right: 50px;
            font-size: 1.1rem;
            height: 48px;
        }
        
        .unit-label {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-20%);
            color: var(--secondary-text);
            font-size: 0.9rem;
        }
        
        .trade-info {
            background-color: var(--medium-bg);
            border-radius: 8px;
            padding: 12px;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }
        
        .info-item:last-child {
            margin-bottom: 0;
        }
        
        .advanced-options {
            margin-top: 5px;
        }
        
        .advanced-options a {
            color: var(--primary-color);
            text-decoration: none;
            font-size: 0.9rem;
            display: block;
            text-align: center;
        }
        
        #more-options-content {
            margin-top: 15px;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }
        
        .btn-submit-trade {
            padding: 15px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1.1rem;
            text-align: center;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-buy {
            background-color: var(--success-color);
            color: white;
        }
        
        .btn-buy:hover {
            background-color: #1ca350;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(34, 197, 94, 0.3);
        }
        
        .btn-sell {
            background-color: var(--danger-color);
            color: white;
        }
        
        .btn-sell:hover {
            background-color: #dc2626;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3);
        }
        
        /* Amount slider visual improvements - complete overhaul */
        .amount-slider-container {
            margin: 5px 0 15px;
            position: relative;
        }
        
        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.75rem;
            color: var(--secondary-text);
        }
        
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: var(--border-color);
            border-radius: 4px;
            margin: 15px 0 5px;
            width: 100%;
        }
        
        /* Webkit (Chrome, Safari, newer Edge) */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(13, 110, 253, 0.5);
            border: none;
        }
        
        /* Firefox */
        input[type=range]::-moz-range-thumb {
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(13, 110, 253, 0.5);
            border: none;
        }
        
        /* MS Edge and IE */
        input[type=range]::-ms-thumb {
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(13, 110, 253, 0.5);
            border: none;
        }
        
        /* Track styling for different browsers */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: var(--border-color);
            border-radius: 2px;
        }
        
        input[type=range]::-moz-range-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: var(--border-color);
            border-radius: 2px;
        }
        
        input[type=range]::-ms-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: transparent;
            border-color: transparent;
            color: transparent;
        }
        
        input[type=range]::-ms-fill-lower {
            background: var(--primary-color);
            border-radius: 2px;
        }
        
        input[type=range]::-ms-fill-upper {
            background: var(--border-color);
            border-radius: 2px;
        }
        
        input[type=range]:focus {
            outline: none;
        }
        
        /* Active amount percentage marker styling */
        .slider-labels span {
            position: relative;
            padding-top: 15px;
        }
        
        .slider-labels span:before {
            content: "";
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 1px;
            height: 8px;
            background-color: var(--secondary-text);
        }
        
        .slider-labels span.active {
            color: var(--primary-color);
            font-weight: 600;
        }
        
        .slider-labels span.active:before {
            background-color: var(--primary-color);
            height: 12px;
        }
        
        /* Badge and input group styling */
        .tp-badge {
            background-color: rgba(34, 197, 94, 0.2);
            color: var(--success-color);
        }
        
        .sl-badge {
            background-color: rgba(239, 68, 68, 0.2);
            color: var(--danger-color);
        }
        
        .input-group {
            display: flex;
            width: 100%;
        }
        
        .input-group-text {
            display: flex;
            align-items: center;
            padding: 0 10px;
            background-color: var(--medium-bg);
            border: 1px solid var(--border-color);
            border-left: none;
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
        }
        
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        /* Amount input styling */
        .input-with-badge {
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .amount-badge {
            position: absolute;
            right: 10px;
            background-color: var(--medium-bg);
            color: var(--secondary-text);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            pointer-events: none;
        }
        
        .form-control:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
            outline: none;
        }
        
        /* Hide scrollbars throughout the WebTrader */
        ::-webkit-scrollbar {
            width: 0;
            height: 0;
            background: transparent;
            display: none;
        }
        
        /* For Firefox */
        * {
            scrollbar-width: none;
        }
        
        /* For Internet Explorer and Edge */
        * {
            -ms-overflow-style: none;
        }
        
        /* Remove outlines from all focusable elements */
        :focus {
            outline: none;
        }
        
        /* Ensure content still scrollable but scrollbars invisible */
        .instruments-list, 
        .chart-area, 
        .trading-panel-pro,
        .main-content,
        .trades-section {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        /* Hide any remaining browser UI controls */
        input[type="range"]::-webkit-slider-thumb,
        input[type="range"]::-moz-range-thumb,
        input[type="range"]::-ms-thumb {
            opacity: 0.9;
            border: none;
            box-shadow: 0 0 5px rgba(13, 110, 253, 0.5);
        }
        
        /* Style the amount slider more discretely */
        input[type=range] {
            background: rgba(45, 52, 70, 0.5);
            border: none;
            height: 4px;
        }
        
        /* Custom track styling (the line) */
        input[type=range]::-webkit-slider-runnable-track,
        input[type=range]::-moz-range-track,
        input[type=range]::-ms-track {
            height: 4px;
            background: rgba(45, 52, 70, 0.5);
            border: none;
        }
        
        /* Additional market data styling */
        .market-data-wrapper {
            padding: 5px 0;
        }

        /* Add styles for leverage selector and margin info */
        .leverage-selector {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .leverage-selector label {
            display: block;
            margin-bottom: 5px;
            color: #999;
        }

        .leverage-selector select {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            border-radius: 4px;
        }

        .margin-info {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .margin-info div {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .margin-info label {
            color: #999;
        }

        .margin-info span {
            color: #fff;
            font-weight: bold;
        }

        /* Update existing styles */
        .trading-panel {
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            margin-top: 20px;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .balance-info {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-right: 20px;
            background-color: var(--medium-bg);
            padding: 8px 15px;
            border-radius: 8px;
        }

        .balance-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 5px;
        }

        .balance-label {
            font-size: 0.7rem;
            color: var(--secondary-text);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .balance-value {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-color);
        }

        .username {
            font-weight: 600;
            color: var(--text-color);
            white-space: nowrap;
            padding: 0 10px;
            border-left: 1px solid var(--border-color);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: var(--darker-bg);
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .logo {
            display: flex;
            align-items: center;
        }

        .logo-img {
            width: 30px;
            height: 30px;
            margin-right: 0.5rem;
            color: white;
        }

        .logo-text {
            font-size: 1.25rem;
            font-weight: 700;
            color: white;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .balance-info {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            background-color: var(--medium-bg);
            padding: 0.5rem;
            border-radius: 5px;
            margin-right: 1rem;
            max-width: 750px;
        }

        .balance-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 90px;
            text-align: center;
        }

        .balance-label {
            font-size: 0.7rem;
            color: var(--secondary-text);
            text-transform: uppercase;
            margin-bottom: 0.25rem;
        }

        .balance-value {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .username {
            font-weight: 600;
            color: white;
        }

        .header-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .return-admin-btn, .logout-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 15px;
            font-weight: 600;
            border-radius: 5px;
        }

        .return-admin-btn:hover {
            background-color: #c29d00;
        }

        .logout-btn {
            background-color: var(--danger-color);
            border-color: var(--danger-color);
            color: white;
        }

        .logout-btn:hover {
            background-color: #c82333;
            border-color: #bd2130;
        }
    </style>
</head>
<body>
    {% if 'admin_user_id' in session %}
    <!-- Admin mode indicator removed for cleaner design -->
    {% endif %}
    
    <div class="trading-platform">
        <!-- Header -->
        <div class="header">
            <div class="logo">
                <img src="{{ url_for('static', filename='imgs/bootstrap-solid.svg') }}" alt="Logo" class="logo-img">
                <span class="logo-text">WebTrader</span>
            </div>
            
            <div class="user-info">
                <div class="balance-info">
                    <div class="balance-item">
                        <span class="balance-label">BALANCE:</span>
                        <span class="balance-value" id="user-balance">${{ "%.2f"|format(current_user.current_balance) }}</span>
                    </div>
                    <div class="balance-item">
                        <span class="balance-label">EQUITY:</span>
                        <span class="balance-value" id="user-equity">${{ "%.2f"|format(current_user.equity) }}</span>
                    </div>
                    <div class="balance-item">
                        <span class="balance-label">MARGIN:</span>
                        <span class="balance-value" id="user-margin">$0.00</span>
                    </div>
                    <div class="balance-item">
                        <span class="balance-label">FREE MARGIN:</span>
                        <span class="balance-value" id="user-free-margin">${{ "%.2f"|format(current_user.equity) }}</span>
                    </div>
                    <div class="balance-item">
                        <span class="balance-label">MARGIN LEVEL:</span>
                        <span class="balance-value" id="user-margin-level">âˆž%</span>
                    </div>
                    <div class="balance-item">
                        <span class="balance-label">CREDIT:</span>
                        <span class="balance-value">${{ "%.2f"|format(current_user.credit_balance) }}</span>
                    </div>
                    <div class="balance-item">
                        <span class="balance-label">BONUS:</span>
                        <span class="balance-value">${{ "%.2f"|format(current_user.bonus_balance) }}</span>
                    </div>
                </div>
                
                <span class="username">{{ current_user.first_name }} {{ current_user.last_name }}</span>
                
                <div class="header-buttons">
                    {% if 'admin_user_id' in session %}
                    <a href="{{ url_for('leads.return_to_admin') }}" class="btn btn-warning return-admin-btn">
                        <i class="fas fa-sign-out-alt"></i> Return to Admin
                    </a>
                    {% endif %}
                    
                    <a href="{{ url_for('users.logout') }}" class="btn btn-danger logout-btn">
                        <i class="fas fa-power-off"></i> Logout
                    </a>
                </div>
            </div>
        </div>
        
        <!-- Market Data Ticker -->
        <div class="market-data">
            {% for instrument in instruments %}
            <div class="market-item">
                <span class="symbol">{{ instrument.symbol }}</span>
                <span class="price">
                    {% if instrument.type == 'forex' %}
                        {{ "%.4f"|format(instrument.current_price) }}
                    {% else %}
                        ${{ "%.2f"|format(instrument.current_price) }}
                    {% endif %}
                </span>
            </div>
            {% endfor %}
        </div>
        
        <!-- Content Area -->
        <div class="content-wrapper">
            <!-- Trading Instruments List -->
            <div class="instruments-list">
                <div class="instruments-header">
                    <h5>Trading Instruments</h5>
                    <div>
                        <button class="btn btn-sm btn-outline-secondary">
                            <i class="fas fa-filter"></i>
                        </button>
                    </div>
                </div>
                
                <div class="market-filter-buttons">
                    <button class="market-filter-btn active" onclick="filterInstruments('all')">
                        <i class="fas fa-globe"></i> All
                    </button>
                    <button class="market-filter-btn" onclick="filterInstruments('crypto')">
                        <i class="fab fa-bitcoin"></i> Crypto
                    </button>
                    <button class="market-filter-btn" onclick="filterInstruments('stock')">
                        <i class="fas fa-chart-line"></i> Stocks
                    </button>
                    <button class="market-filter-btn" onclick="filterInstruments('forex')">
                        <i class="fas fa-dollar-sign"></i> Forex
                    </button>
                    <button class="market-filter-btn" onclick="filterInstruments('commodities')">
                        <i class="fas fa-oil-can"></i> Commod.
                    </button>
                </div>
                
                <table class="instruments-table">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Price</th>
                            <th>Change</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for instrument in instruments %}
                        <tr data-instrument-id="{{ instrument.id }}" 
                            data-symbol="{{ instrument.symbol }}" 
                            data-type="{{ instrument.type }}" 
                            onclick="selectInstrument('{{ instrument.id }}')">
                            <td>{{ instrument.symbol }}</td>
                            <td>
                                {% if instrument.type == 'forex' %}
                                    {{ "%.4f"|format(instrument.current_price) }}
                                {% elif instrument.type == 'crypto' %}
                                    ${{ "%.2f"|format(instrument.current_price) }}
                                {% else %}
                                    ${{ "%.2f"|format(instrument.current_price) }}
                                {% endif %}
                            </td>
                            <td class="price-change {% if loop.index % 2 == 0 %}price-up{% else %}price-down{% endif %}">
                                <i class="fas fa-caret-{% if loop.index % 2 == 0 %}up{% else %}down{% endif %}"></i>
                                <span>{% if loop.index % 2 == 0 %}+{% else %}-{% endif %}0.{{ loop.index }}%</span>
                            </td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>

            <!-- Chart Area (Includes Chart and Trades Tables Below) -->
            <div class="chart-area">
                <div class="chart-header">
                    <div class="current-symbol">
                        <span id="current-symbol-text">BTC/USD</span>
                        <span id="current-price" class="price-up">--.--</span> <!-- Updated by JS -->
                    </div>
                    <div>
                        <button class="btn btn-sm btn-outline-secondary">1m</button>
                        <button class="btn btn-sm btn-outline-secondary">5m</button>
                        <button class="btn btn-sm btn-outline-secondary active">15m</button>
                        <button class="btn btn-sm btn-outline-secondary">1h</button>
                        <button class="btn btn-sm btn-outline-secondary">1d</button>
                    </div>
                </div>
                
                <div class="chart-container" id="tradingview_chart"></div>
                
                <!-- Trades Section (Moved inside chart-area) -->
                <div class="trades-section">
                    <h3 class="section-title">Open Trades</h3>
                    <div class="table-responsive">
                        <table class="trades-table open-trades-table"> {# Add class for targeting #}
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Amount</th>
                                    <th>Entry Price</th> {# Renamed for clarity #}
                                <th>Type</th>
                                <th>Date</th>
                                    <th>Current Price</th> {# Added for P/L Calc #}
                                    <th>P/L ($)</th> {# Added P/L Column #}
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for trade in open_trades %}
                                {# Add data attributes needed for P/L calculation #}
                                <tr class="open-trade-row" 
                                    data-trade-id="{{ trade.id }}" 
                                    data-instrument-id="{{ trade.instrument.id }}" 
                                    data-entry-price="{{ trade.price }}" 
                                    data-trade-amount="{{ trade.amount }}" 
                                    data-trade-type="{{ trade.trade_type }}">
                                    <td>{{ trade.instrument.symbol }}</td>
                                    <td>{{ trade.amount }}</td>
                                    <td>${{ "%.2f"|format(trade.price) }}</td>
                                    <td>
                                        <span class="badge badge-{{ trade.trade_type }}">{{ trade.trade_type | upper }}</span>
                                    </td>
                                    <td>{{ trade.date.strftime('%Y-%m-%d %H:%M') }}</td>
                                    <td class="current-price-cell">--.--</td> {# Cell for current price #}
                                    <td class="profit-loss-cell">--.--</td> {# Cell for P/L #}
                                    <td>
                                        <form method="POST" action="{{ url_for('webtrader.close_trade') }}" style="display:inline;">
                                             <input type="hidden" name="csrf_token" value="{{ csrf_token }}"/>
                                            <input type="hidden" name="trade_id" value="{{ trade.id }}">
                                            <button type="submit" class="btn btn-danger btn-sm">Close</button>
                                        </form>
                                    </td>
                                </tr>
                            {% endfor %}
                                {% if not open_trades %}
                                <tr>
                                    <td colspan="6" class="text-center py-4">No open trades</td>
                                </tr>
                                {% endif %}
                        </tbody>
                    </table>
                </div>
                    
                    <h3 class="section-title mt-4">Pending Orders</h3>
                    <div class="table-responsive">
                        <table class="trades-table">
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>Amount</th>
                                    <th>Price</th>
                                    <th>Type</th>
                                    <th>Order Type</th>
                                    <th>Target Price</th>
                                    <th>Date</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for order in pending_orders %}
                                <tr>
                                    <td>{{ order.instrument.symbol }}</td>
                                    <td>{{ order.amount }}</td>
                                    <td>${{ "%.2f"|format(order.price) }}</td>
                                    <td>
                                        <span class="badge badge-{{ order.trade_type }}">{{ order.trade_type | upper }}</span>
                                    </td>
                                    <td>
                                        <span class="badge order-type-badge">{{ order.order_type | replace('_', ' ') | title }}</span>
                                    </td>
                                    <td>${{ "%.2f"|format(order.target_price) }}</td>
                                    <td>{{ order.date.strftime('%Y-%m-%d %H:%M') }}</td>
                                    <td>
                                        <form method="POST" action="{{ url_for('webtrader.cancel_order') }}" style="display:inline;">
                                             <input type="hidden" name="csrf_token" value="{{ csrf_token }}"/>
                                            <input type="hidden" name="order_id" value="{{ order.id }}">
                                            <button type="submit" class="btn btn-warning btn-sm">Cancel</button>
                                        </form>
                                    </td>
                                </tr>
                                {% endfor %}
                                {% if not pending_orders %}
                                <tr>
                                    <td colspan="8" class="text-center py-4">No pending orders</td>
                                </tr>
                                {% endif %}
                            </tbody>
                        </table>
            </div>

                    <h3 class="section-title mt-4">Closed Trades</h3>
                    <div class="table-responsive">
                        <table class="trades-table">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Amount</th>
                                <th>Price</th>
                                <th>Type</th>
                                <th>Date</th>
                                <th>Profit/Loss</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for trade in closed_trades %}
                                <tr>
                                    <td>{{ trade.instrument.symbol }}</td>
                                    <td>{{ trade.amount }}</td>
                                    <td>${{ "%.2f"|format(trade.price) }}</td>
                                    <td>
                                        <span class="badge badge-{{ trade.trade_type }}">{{ trade.trade_type | upper }}</span>
                                    </td>
                                    <td>{{ trade.date.strftime('%Y-%m-%d %H:%M') }}</td>
                                    <td class="{% if trade.profit_loss is not none and trade.profit_loss > 0 %}price-up{% elif trade.profit_loss is not none and trade.profit_loss < 0 %}price-down{% endif %}">
                                        {{ "%.2f"|format(trade.profit_loss if trade.profit_loss else 0.00) }}
                                    </td>
                                </tr>
                            {% endfor %}
                                {% if not closed_trades %}
                                <tr>
                                    <td colspan="6" class="text-center py-4">No closed trades</td>
                                </tr>
                                {% endif %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
         <!-- Trading Panel - Redesigned (Moved to be sibling of chart-area) -->
         <div class="trading-panel-pro">
             <div class="trade-header">
                 <span id="trade-panel-symbol">--/--</span>
             </div>
             <form class="trading-form-pro" method="POST" action="{{ url_for('webtrader.execute_trade') }}">
                 {{ form.hidden_tag() }}
                 <input type="hidden" id="instrument_id" name="instrument_id" value="{{ instruments[0].id if instruments else '' }}">
                 <input type="hidden" id="trade_type" name="trade_type" value="buy">

                 <div class="price-buttons">
                     <button type="button" class="btn-price btn-sell-price" onclick="setTradeType('sell')">
                         <span>SELL</span>
                         <strong id="sell-price-display">--.--</strong>
                     </button>
                     <button type="button" class="btn-price btn-buy-price active" onclick="setTradeType('buy')">
                         <span>BUY</span>
                         <strong id="buy-price-display">--.--</strong>
                     </button>
                 </div>

                 <!-- Add Leverage Selector -->
                 <div class="form-group">
                     <label for="leverage-select" class="form-label">Leverage</label>
                     <select id="leverage-select" class="form-control" onchange="updateTradeInfo()">
                         <option value="1">1x</option>
                         <option value="2">2x</option>
                         <option value="5" selected>5x</option>
                         <option value="10">10x</option>
                         <option value="20">20x</option>
                         <option value="50">50x</option>
                         <option value="100">100x</option>
                     </select>
                 </div>

                 <div class="form-row">
                     <div class="form-group amount-group">
                         <label for="amount">Amount</label>
                         <div class="input-with-badge">
                             <input type="number" step="any" class="form-control" id="trade_amount" name="amount" placeholder="0.00">
                             <div class="amount-badge" id="amount-unit">---</div>
                         </div>
                     </div>
                 </div>
                 
                 <!-- Add Margin Info Display -->
                 <div class="trade-info">
                     <div class="info-item">
                         <span>Margin Required:</span>
                         <span id="margin-required-value">$0.00</span>
                     </div>
                     <div class="info-item">
                         <span>Effective Leverage:</span>
                         <span id="effective-leverage">1x</span>
                     </div>
                     <div class="info-item">
                         <span>Value:</span>
                         <span id="trade-value">$0.00</span>
                     </div>
                     <div class="info-item">
                         <span>Available Balance:</span>
                         <span id="available-balance">${{ current_user.current_balance }}</span>
                     </div>
                 </div>

                 <div class="advanced-options">
                     <a href="#" onclick="toggleMoreOptions(event)">More Options <i class="fas fa-chevron-down"></i></a>
                     <div id="more-options-content" style="display: none;">
                         <div class="form-group">
                              {{ form.order_type.label(class="form-label") }}
                              {{ form.order_type(class="form-control") }}
                         </div>
                          <div class="form-group" id="target-price-group" style="display:none;">
                              <label class="form-label">Target Price</label>
                              <input type="number" step="any" id="target_price" name="target_price" class="form-control" placeholder="Set Limit/Stop Price">
                          </div>
                         <hr>
                         <div class="form-group">
                             <label for="take_profit">Take Profit</label>
                             <div class="input-group">
                                 <input type="number" step="any" id="take_profit" name="take_profit" class="form-control" placeholder="Set TP Price">
                                 <div class="input-group-text">
                                     <span class="badge tp-badge">+0.00%</span>
                                 </div>
                             </div>
                         </div>
                         <div class="form-group">
                             <label for="stop_loss">Stop Loss</label>
                             <div class="input-group">
                                 <input type="number" step="any" id="stop_loss" name="stop_loss" class="form-control" placeholder="Set SL Price">
                                 <div class="input-group-text">
                                     <span class="badge sl-badge">-0.00%</span>
                                 </div>
                             </div>
                         </div>
                     </div>
                 </div>

                 <button type="submit" class="btn btn-submit-trade btn-buy" id="submit-trade-button">BUY</button>
             </form>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
        // Initialize with empty values
        let currentInstrument = { id: "", symbol: "BTC/USD", name: "Bitcoin", type: "crypto", price: null, precision: 2 };
        let instrumentsData = {};

        // Initialize data from server-side
        {% if instruments and instruments|length > 0 %}
        // Set first instrument as current
        currentInstrument = {
            id: "{{ instruments[0].id }}",
            symbol: "{{ instruments[0].symbol }}",
            name: "{{ instruments[0].name }}",
            type: "{{ instruments[0].type }}",
            price: {{ instruments[0].current_price|default('null') }},
            precision: {% if instruments[0].type == 'crypto' %}6{% else %}2{% endif %}
        };

        // Initialize all instruments data
        instrumentsData = {
        {% for instrument in instruments %}
            "{{ instrument.id }}": {
                symbol: "{{ instrument.symbol }}",
                name: "{{ instrument.name }}",
                type: "{{ instrument.type }}",
                price: {{ instrument.current_price|default(0) }},
                precision: {% if instrument.type == 'crypto' %}6{% else %}2{% endif %}
            }{% if not loop.last %},{% endif %}
        {% endfor %}
        };
        {% endif %}

        // --- TradingView Widget Initialization ---
        window.tvWidget = new TradingView.widget({
            "autosize": true,
            "symbol": "BINANCE:BTCUSDT", // Default symbol
            "interval": "15",
            "timezone": "Etc/UTC",
            "theme": "dark",
            "style": "1",
            "locale": "en",
            "toolbar_bg": "#f1f3f6",
            "enable_publishing": false,
            "allow_symbol_change": true,
            "container_id": "tradingview_chart",
             "studies": [
                "MASimple@tv-basicstudies"
            ]
        });

        document.addEventListener("DOMContentLoaded", function() {
            // Store initial instrument data from data attributes
            const rows = document.querySelectorAll('.instruments-table tbody tr');
            rows.forEach(row => {
                const id = row.getAttribute('data-instrument-id');
                const symbol = row.getAttribute('data-symbol'); // Get symbol from data attribute
                const type = row.getAttribute('data-type'); // Get type from data attribute
                
                if (id && symbol && type) {
                     let precision = 2;
                     if (type === 'crypto') precision = 6;
                     else if (type === 'forex') precision = 4;
                
                     instrumentsData[id] = { 
                        symbol: symbol,
                        name: '', // Consider adding name as data attribute if needed
                        type: type,
                        precision: precision
                    };
                     console.log(`Stored instrument data: ID=${id}, Symbol=${symbol}, Type=${type}, Precision=${precision}`); // Log stored data
                } else {
                     console.warn("Missing data attribute(s) for instrument row:", row);
                }
            });

            // Select the first instrument by default if available
            const firstRow = document.querySelector('.instruments-table tbody tr');
            if (firstRow) {
                selectInstrument(firstRow.getAttribute('data-instrument-id'));
            }
            
            // Add event listener for order type change
            const orderTypeSelect = document.getElementById('order_type');
            if (orderTypeSelect) {
                 orderTypeSelect.addEventListener('change', function() {
        const targetPriceGroup = document.getElementById('target-price-group');
                    if (this.value === 'limit' || this.value === 'stop') {
            targetPriceGroup.style.display = 'block';
        } else {
            targetPriceGroup.style.display = 'none';
        }
    });
                 // Trigger change initially to set visibility
                 orderTypeSelect.dispatchEvent(new Event('change'));
            }
            
             // Add event listener for amount change to update trade info
             const amountInput = document.getElementById('trade_amount');
             if (amountInput) {
                 amountInput.addEventListener('input', updateTradeInfo);
             }
             
             // Set initial trade type button state
             setTradeType('buy');
             
             // Initial P/L calculation and start periodic updates
             updateAllOpenTradesPL(); 
             setInterval(updateAllOpenTradesPL, 15000); // Update P/L every 15 seconds
             
             // Start sliding ticker animation
             startSlidingTicker(); 
             
             // Fix notification clicking issue
             const marketItems = document.querySelectorAll('.market-item');
             marketItems.forEach(item => {
                 item.addEventListener('click', function(e) {
                     e.preventDefault();
                     const symbol = this.querySelector('.symbol').textContent;
                     console.log('Clicked on market item:', symbol);
                     // Find instrument with this symbol to select it
                     const instrumentId = Object.keys(instrumentsData).find(id => 
                         instrumentsData[id].symbol === symbol);
                     if (instrumentId) {
                         selectInstrument(instrumentId);
                     }
                 });
             });
             
             // Make all market items and notification elements clickable
             document.querySelectorAll('.market-data .market-item, .notification-item').forEach(element => {
                 element.style.cursor = 'pointer';
                 element.style.pointerEvents = 'auto';
             });
        });

        function updateMarketDataTicker() {
            const tickerItems = document.querySelectorAll('.market-data .market-item');
            tickerItems.forEach(item => {
                 const symbol = item.querySelector('.symbol').textContent;
                 // Find instrument ID from our stored data based on symbol
                 const instrumentId = Object.keys(instrumentsData).find(id => instrumentsData[id].symbol === symbol);
                 
                 if (instrumentId) {
                     fetch(`/webtrader/get_price?instrument_id=${instrumentId}`)
                        .then(response => response.json())
                        .then(data => {
                            if (data.current_price !== null) {
                                const priceDisplay = item.querySelector('.price');
                                const instrumentType = instrumentsData[instrumentId]?.type || 'unknown';
                                const currentPrice = parseFloat(data.current_price);
                                
                                // Determine formatted price based on asset type and value
                                let formattedPrice;
                                if (instrumentType === 'crypto') {
                                    if (currentPrice >= 1000) {
                                        formattedPrice = currentPrice.toFixed(2); // BTC, ETH etc.
                                    } else if (currentPrice >= 10) {
                                        formattedPrice = currentPrice.toFixed(3);
                                    } else if (currentPrice >= 1) {
                                        formattedPrice = currentPrice.toFixed(4);
                                    } else {
                                        formattedPrice = currentPrice.toFixed(6); // Low value tokens
                                    }
                                } else if (instrumentType === 'forex') {
                                    formattedPrice = currentPrice.toFixed(4); // Standard forex precision
                                } else {
                                    formattedPrice = currentPrice.toFixed(2); // Stocks, commodities
                                }
                                
                                // Determine price change (requires previous price - simplified placeholder)
                                const currentPriceText = priceDisplay.firstChild.textContent.trim().replace(/[^\d.]/g, '');
                                const oldPrice = parseFloat(currentPriceText) || currentPrice;
                                const changeDir = currentPrice > oldPrice ? 'up' : (currentPrice < oldPrice ? 'down' : 'unchanged');
                                
                                priceDisplay.className = `price price-${changeDir}`;
                                let priceHtml;
                                
                                if (instrumentType === 'forex') {
                                     priceHtml = formattedPrice; // No $ for forex
                                } else if (instrumentType === 'crypto') {
                                    priceHtml = `$${formattedPrice}`;
                                } else {
                                    priceHtml = `$${formattedPrice}`;
                                }
                                
                                // Placeholder change %
                                const changePercent = ((currentPrice - oldPrice) / oldPrice * 100) || (Math.random() * 1 - 0.5);
                                priceHtml += `<small>${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%</small>`;
                                priceDisplay.innerHTML = priceHtml;
                            }
                        })
                        .catch(error => console.error(`Error fetching ticker price for ${symbol}:`, error));
                 }
            });
        }
        
         function setTradeType(type) {
             document.getElementById('trade_type').value = type;
             const submitButton = document.getElementById('submit-trade-button');
             if (submitButton) {
                 submitButton.textContent = type.toUpperCase();
                 submitButton.className = `btn btn-submit-trade btn-${type}`;
             }
             // Update active state of price buttons
             document.querySelector('.btn-sell-price').classList.toggle('active', type === 'sell');
             document.querySelector('.btn-buy-price').classList.toggle('active', type === 'buy');
         }
        
        function selectInstrument(instrumentId) {
            instrumentId = parseInt(instrumentId);
            console.log(`Selecting instrument ID: ${instrumentId}`);
            
            if (!instrumentId || !instrumentsData[instrumentId]) {
                console.error("Invalid instrument ID or data not found");
                return;
            }
            
            // Update global state
            currentInstrument.id = instrumentId;
            currentInstrument.symbol = instrumentsData[instrumentId].symbol;
            currentInstrument.type = instrumentsData[instrumentId].type;
            currentInstrument.precision = instrumentsData[instrumentId].precision;
            
            document.getElementById('instrument_id').value = instrumentId;
            
            // Update Trade Panel Header & Amount Unit
            document.getElementById('trade-panel-symbol').textContent = currentInstrument.symbol;
            let unit = currentInstrument.symbol;
            if (unit.includes('/')) {
                unit = unit.split('/')[0];
            }
            document.getElementById('amount-unit').textContent = unit;
            
            // Update Symbol Text Above Chart
            document.getElementById('current-symbol-text').textContent = currentInstrument.symbol;
            
            // Fetch price and update UI elements
            updateInstrumentPriceAndUI();

            // Update TradingView Chart with forced refresh
            let tvSymbol = '';
            const symbol = currentInstrument.symbol;
            const type = currentInstrument.type;
            
            if (type === 'crypto') {
                const base = symbol.split('/')[0];
                const quote = symbol.split('/')[1] || 'USD';
                tvSymbol = `BINANCE:${base}${quote === 'USD' ? 'USDT' : quote}`;
            } else if (type === 'stock') {
                tvSymbol = `NASDAQ:${symbol}`;
            } else if (type === 'forex') {
                tvSymbol = `FX:${symbol.replace('/', '')}`;
            } else if (type === 'commodities') {
                if (symbol === 'GOLD') tvSymbol = 'TVC:GOLD';
                else if (symbol === 'SILVER') tvSymbol = 'TVC:SILVER';
                else if (symbol === 'OIL' || symbol === 'WTI') tvSymbol = 'NYMEX:CL1!';
                else if (symbol === 'NATGAS') tvSymbol = 'NYMEX:NG1!';
                else tvSymbol = symbol;
            }
            
            if (window.tvWidget && tvSymbol) {
                // Remove existing widget
                const chartContainer = document.getElementById('tradingview_chart');
                chartContainer.innerHTML = '';
                
                // Create new widget with the new symbol
                window.tvWidget = new TradingView.widget({
                    "autosize": true,
                    "symbol": tvSymbol,
                    "interval": "15",
                    "timezone": "Etc/UTC",
                    "theme": "dark",
                    "style": "1",
                    "locale": "en",
                    "toolbar_bg": "#f1f3f6",
                    "enable_publishing": false,
                    "allow_symbol_change": true,
                    "container_id": "tradingview_chart",
                    "studies": [
                        "MASimple@tv-basicstudies"
                    ]
                });
            }
            
            // Highlight selected row in the list
            const rows = document.querySelectorAll('.instruments-table tbody tr');
            rows.forEach(row => {
                row.classList.remove('active');
                if (parseInt(row.getAttribute('data-instrument-id')) === instrumentId) {
                    row.classList.add('active');
                }
            });
            
            // Reset amount and update trade info
            document.getElementById('trade_amount').value = '';
            updateTradeInfo();
        }
        
        function updateInstrumentPriceAndUI() {
            if (!currentInstrument.id) return;
            
            fetch(`/webtrader/get_price?instrument_id=${currentInstrument.id}`)
                .then(response => response.json())
                .then(data => {
                    if (data.current_price !== null) {
                        const price = parseFloat(data.current_price);
                        currentInstrument.price = price;
                        const precision = currentInstrument.precision;
                        
                        // Format price based on instrument type
                        let formattedPrice;
                        if (currentInstrument.type === 'crypto') {
                            // Use dynamic precision - fewer decimals for higher value cryptos
                            if (price >= 1000) {
                                formattedPrice = price.toFixed(2); // BTC, ETH etc.
                            } else if (price >= 10) {
                                formattedPrice = price.toFixed(3);
                            } else if (price >= 1) {
                                formattedPrice = price.toFixed(4);
                            } else {
                                formattedPrice = price.toFixed(6); // Low value tokens
                            }
                        } else if (currentInstrument.type === 'forex') {
                            formattedPrice = price.toFixed(4); // Standard forex precision
                        } else {
                            formattedPrice = price.toFixed(2); // Stocks, commodities
                        }
                        
                        // Update price in the header above chart
                        document.getElementById('current-price').textContent = formattedPrice;
                        // Update class for color (up/down) - requires previous price, simplified
                        document.getElementById('current-price').className = (Math.random() > 0.5 ? 'price-up' : 'price-down');

                        // Update Bid/Ask in the trading panel (simulate small spread)
                        const spread = price * 0.0005; // Example: 0.05% spread
                        const sellPrice = (price - spread / 2);
                        const buyPrice = (price + spread / 2);
                        
                        // Format sell/buy price with same precision as main price
                        let formattedSellPrice, formattedBuyPrice;
                        if (currentInstrument.type === 'crypto') {
                            if (price >= 1000) {
                                formattedSellPrice = sellPrice.toFixed(2);
                                formattedBuyPrice = buyPrice.toFixed(2);
                            } else if (price >= 10) {
                                formattedSellPrice = sellPrice.toFixed(3);
                                formattedBuyPrice = buyPrice.toFixed(3);
                            } else if (price >= 1) {
                                formattedSellPrice = sellPrice.toFixed(4);
                                formattedBuyPrice = buyPrice.toFixed(4);
                            } else {
                                formattedSellPrice = sellPrice.toFixed(6);
                                formattedBuyPrice = buyPrice.toFixed(6);
                            }
                        } else if (currentInstrument.type === 'forex') {
                            formattedSellPrice = sellPrice.toFixed(4);
                            formattedBuyPrice = buyPrice.toFixed(4);
                        } else {
                            formattedSellPrice = sellPrice.toFixed(2);
                            formattedBuyPrice = buyPrice.toFixed(2);
                        }
                        
                        document.getElementById('sell-price-display').textContent = formattedSellPrice;
                        document.getElementById('buy-price-display').textContent = formattedBuyPrice;
                        
                        // Update price in the instrument list table
                        const row = document.querySelector(`.instruments-table tbody tr[data-instrument-id="${currentInstrument.id}"]`);
                        if (row) {
                            const priceCell = row.querySelector('td:nth-child(2)');
                            let priceHtml;
                            
                            if (currentInstrument.type === 'forex') {
                                priceHtml = formattedPrice; // No $ for forex
                            } else if (currentInstrument.type === 'crypto') {
                                priceHtml = `$${formattedPrice}`;
                            } else {
                                priceHtml = `$${formattedPrice}`;
                            }
                            
                            priceCell.innerHTML = priceHtml;
                        }
                        
                        // Update trade info based on new price
                        updateTradeInfo();
                    }
                })
                .catch(error => console.error('Error fetching instrument price:', error));
        }

        // Auto-refresh prices every 60 seconds (1 minute)
        setInterval(function() {
            // Update the selected instrument price from API
            if (currentInstrument.id) { // Only update if an instrument is selected
                 updateInstrumentPriceAndUI();
            }
            // Update market data ticker for all visible instruments
            updateMarketDataTicker();
            // Note: P/L updates handled by a separate interval
        }, 60000); // 60 seconds refresh
        
        // --- New Function for Real-time P/L ---
        function updateAllOpenTradesPL() {
            console.log("Updating P/L for open trades...");
            const openTradeRows = document.querySelectorAll('.open-trade-row');
            openTradeRows.forEach(row => {
                const instrumentId = row.getAttribute('data-instrument-id');
                const entryPrice = parseFloat(row.getAttribute('data-entry-price'));
                const tradeAmount = parseFloat(row.getAttribute('data-trade-amount'));
                const tradeType = row.getAttribute('data-trade-type');
                const plCell = row.querySelector('.profit-loss-cell');
                const currentPriceCell = row.querySelector('.current-price-cell');
                
                if (!instrumentId || isNaN(entryPrice) || isNaN(tradeAmount) || !tradeType || !plCell || !currentPriceCell) {
                    console.warn("Missing data for P/L calculation on row:", row);
                    return; // Skip if data is missing
                }
                
                // Fetch the current price for this instrument
                fetch(`/webtrader/get_price?instrument_id=${instrumentId}`)
            .then(response => response.json())
            .then(data => {
                        if (data.current_price !== null) {
                            const currentPrice = parseFloat(data.current_price);
                            const instrumentData = instrumentsData[instrumentId];
                            const precision = instrumentData ? instrumentData.precision : 2;
                            
                            // Update current price cell
                            currentPriceCell.textContent = currentPrice.toFixed(precision);
                            
                            // Calculate P/L
                            let profitLoss = 0;
                            if (tradeType === 'buy') {
                                profitLoss = (currentPrice - entryPrice) * tradeAmount;
                            } else if (tradeType === 'sell') {
                                profitLoss = (entryPrice - currentPrice) * tradeAmount;
                            }
                            
                            // Update P/L cell
                            plCell.textContent = profitLoss.toFixed(2);
                            plCell.className = 'profit-loss-cell ' + (profitLoss >= 0 ? 'price-up' : 'price-down');
                        } else {
                             console.warn(`Could not get current price for instrument ID ${instrumentId} to calculate P/L`);
                             currentPriceCell.textContent = '--.--';
                             plCell.textContent = '--.--';
                             plCell.className = 'profit-loss-cell';
                        }
                    })
                    .catch(error => {
                        console.error(`Error fetching price for P/L calc (Instrument ID ${instrumentId}):`, error);
                        currentPriceCell.textContent = 'Error';
                        plCell.textContent = 'Error';
                        plCell.className = 'profit-loss-cell price-down';
                     });
            });
        }
        // --- End P/L Function ---
        
         function toggleMoreOptions(event) {
            event.preventDefault();
            const content = document.getElementById('more-options-content');
            const link = event.currentTarget; // Use currentTarget
            const icon = link.querySelector('i');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                if (icon) icon.className = 'fas fa-chevron-up';
            } else {
                content.style.display = 'none';
                if (icon) icon.className = 'fas fa-chevron-down';
            }
         }
         
         function updateTradeInfo() {
             // Calculate and display Margin Impact, Trade Value based on Amount and Price
             const amountInput = document.getElementById('trade_amount');
             const amount = parseFloat(amountInput.value) || 0;
             const price = currentInstrument.price || 0;
             const type = currentInstrument.type;
             let tradeValue = 0;
             let marginImpact = 0;
             const leverage = 50; // Example leverage, make this dynamic later
             
             if (amount > 0 && price > 0) {
                 tradeValue = amount * price;
                 // Margin calculation depends heavily on asset type and broker rules
                 // Simple example: margin = value / leverage
                 marginImpact = tradeValue / leverage;
             }
             
             const valuePrecision = 2;
             document.getElementById('trade-value').textContent = `$ ${tradeValue.toFixed(valuePrecision)}`;
             document.getElementById('margin-impact').textContent = `$ ${marginImpact.toFixed(valuePrecision)}`;
         }

        function filterInstruments(type) {
            // Update active state on filter buttons
            const filterButtons = document.querySelectorAll('.market-filter-btn');
            filterButtons.forEach(button => {
                button.classList.remove('active');
                // Find the text content of the button (ignoring the icon)
                const buttonText = button.textContent.trim().toLowerCase();
                if ((type === 'all' && buttonText.includes('all')) ||
                    (type === 'crypto' && buttonText.includes('crypto')) ||
                    (type === 'stock' && buttonText.includes('stocks')) ||
                    (type === 'forex' && buttonText.includes('forex')) ||
                    (type === 'commodities' && buttonText.includes('commod'))) {
                    button.classList.add('active');
                }
            });
            
            // Filter the instruments table
            const rows = document.querySelectorAll('.instruments-table tbody tr');
            rows.forEach(row => {
                const rowType = row.getAttribute('data-type');
                if (type === 'all') {
                    row.style.display = '';
                } else {
                    row.style.display = (rowType === type) ? '' : 'none';
                }
            });
        }
        
        // --- Sliding Ticker Logic ---
        function startSlidingTicker() {
            const ticker = document.querySelector('.market-data');
            if (!ticker) return;
            
            // Clone all market items for seamless scrolling
            const items = ticker.querySelectorAll('.market-item');
            const itemsArray = Array.from(items);
            
            // Create wrapper if it doesn't exist
            let wrapper = ticker.querySelector('.market-data-wrapper');
            if (!wrapper) {
                wrapper = document.createElement('div');
                wrapper.className = 'market-data-wrapper';
                wrapper.style.display = 'flex';
                wrapper.style.position = 'relative';
                wrapper.style.whiteSpace = 'nowrap';
                
                // Add original items
                itemsArray.forEach(item => {
                    wrapper.appendChild(item.cloneNode(true));
                });
                
                // Add duplicates for seamless loop
                itemsArray.forEach(item => {
                    wrapper.appendChild(item.cloneNode(true));
                });
                
                ticker.innerHTML = '';
                ticker.appendChild(wrapper);
            }
            
            let position = 0;
            const speed = 1; // Adjust speed as needed
            
            function animate() {
                position -= speed;
                const firstSetWidth = wrapper.children[0].offsetWidth * itemsArray.length;
                
                if (-position >= firstSetWidth) {
                    position = 0;
                }
                
                wrapper.style.transform = `translateX(${position}px)`;
                requestAnimationFrame(animate);
            }
            
            animate();
        }

        // Update market data ticker prices
        function updateMarketDataTicker() {
            const tickerItems = document.querySelectorAll('.market-data .market-item');
            tickerItems.forEach(item => {
                const symbol = item.querySelector('.symbol').textContent;
                // Find instrument ID from our stored data based on symbol
                const instrumentId = Object.keys(instrumentsData).find(id => 
                    instrumentsData[id].symbol === symbol);
                
                if (instrumentId) {
                    fetch(`/webtrader/get_price?instrument_id=${instrumentId}`)
                        .then(response => response.json())
                        .then(data => {
                            if (data.current_price !== null) {
                                const priceDisplay = item.querySelector('.price');
                                const currentPrice = parseFloat(data.current_price);
                                const oldPrice = parseFloat(priceDisplay.getAttribute('data-last-price') || currentPrice);
                                
                                // Store new price for next comparison
                                priceDisplay.setAttribute('data-last-price', currentPrice.toString());
                                
                                // Format price based on type
                                let formattedPrice;
                                if (symbol.includes('/')) {
                                    if (symbol.startsWith('BTC')) {
                                        formattedPrice = currentPrice.toFixed(2);
                                    } else {
                                        formattedPrice = currentPrice.toFixed(4);
                                    }
                                } else {
                                    formattedPrice = currentPrice.toFixed(2);
                                }
                                
                                // Calculate price change
                                const priceChange = ((currentPrice - oldPrice) / oldPrice) * 100;
                                const changeClass = currentPrice >= oldPrice ? 'price-up' : 'price-down';
                                
                                // Update price display
                                priceDisplay.className = `price ${changeClass}`;
                                priceDisplay.innerHTML = `$${formattedPrice} <small>${priceChange >= 0 ? '+' : ''}${priceChange.toFixed(2)}%</small>`;
                            }
                        })
                        .catch(error => console.error(`Error updating ticker price for ${symbol}:`, error));
                }
            });
        }
        // Update open trades prices and P/L
        function updateAllOpenTradesPL() {
            const openTradeRows = document.querySelectorAll('.open-trade-row');
            openTradeRows.forEach(row => {
                const instrumentId = row.getAttribute('data-instrument-id');
                const entryPrice = parseFloat(row.getAttribute('data-entry-price'));
                const tradeAmount = parseFloat(row.getAttribute('data-trade-amount'));
                const tradeType = row.getAttribute('data-trade-type');
                
                if (!instrumentId || !entryPrice || !tradeAmount || !tradeType) return;
                
                fetch(`/webtrader/get_price?instrument_id=${instrumentId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.current_price !== null) {
                            const currentPrice = parseFloat(data.current_price);
                            
                            // Update current price cell
                            const currentPriceCell = row.querySelector('.current-price-cell');
                            if (currentPriceCell) {
                                currentPriceCell.textContent = currentPrice.toFixed(2);
                            }
                            
                            // Calculate P/L
                            let profitLoss;
                            if (tradeType.toLowerCase() === 'buy') {
                                profitLoss = (currentPrice - entryPrice) * tradeAmount;
                            } else {
                                profitLoss = (entryPrice - currentPrice) * tradeAmount;
                            }
                            
                            // Update P/L cell
                            const plCell = row.querySelector('.profit-loss-cell');
                            if (plCell) {
                                plCell.textContent = profitLoss.toFixed(2);
                                plCell.className = `profit-loss-cell ${profitLoss >= 0 ? 'price-up' : 'price-down'}`;
                            }
                        }
                    })
                    .catch(error => console.error('Error updating trade P/L:', error));
            });
        }

        // Start periodic updates when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Start the sliding ticker
            startSlidingTicker();
            
            // Update market data ticker every 5 seconds
            setInterval(updateMarketDataTicker, 5000);
            
            // Update open trades P/L every 3 seconds
            setInterval(updateAllOpenTradesPL, 3000);
        });

        // --- Amount Slider functionality ---
        document.addEventListener("DOMContentLoaded", function() {
            // Setup amount slider
            const amountSlider = document.getElementById('amount-slider');
            const amountInput = document.getElementById('trade_amount');
            const sliderLabels = document.querySelectorAll('.slider-labels span');
            
            if (amountSlider && amountInput) {
                // Update input value when slider moves
                amountSlider.addEventListener('input', function() {
                    // Calculate amount based on percentage and user balance
                    const percentage = this.value;
                    const balance = parseFloat("{{ current_user.current_balance }}") || 1000;
                    const maxAmount = balance / (currentInstrument.price || 1);
                    
                    // Format amount based on asset type and value
                    let scaledAmount;
                    if (currentInstrument.type === 'crypto') {
                        if (currentInstrument.price >= 1000) {
                            // For high-value cryptos, show fewer decimals
                            scaledAmount = (maxAmount * percentage / 100).toFixed(4);
                        } else {
                            // For lower-value cryptos, more precision
                            scaledAmount = (maxAmount * percentage / 100).toFixed(6);
                        }
                    } else if (currentInstrument.type === 'forex') {
                        scaledAmount = (maxAmount * percentage / 100).toFixed(2);
                    } else {
                        // Stocks, commodities, etc.
                        scaledAmount = (maxAmount * percentage / 100).toFixed(2);
                    }
                    
                    // Update input field
                    amountInput.value = scaledAmount;
                    
                    // Update slider labels active state
                    updateSliderLabels(percentage);
                    
                    // Update trade info based on new amount
                    updateTradeInfo();
                });
                
                // Allow manual input to adjust slider
                amountInput.addEventListener('input', function() {
                    const inputAmount = parseFloat(this.value) || 0;
                    const balance = parseFloat("{{ current_user.current_balance }}") || 1000;
                    const maxAmount = balance / (currentInstrument.price || 1);
                    
                    // Calculate percentage of max amount
                    const percentage = Math.min(100, (inputAmount / maxAmount) * 100);
                    
                    // Update slider position
                    amountSlider.value = percentage;
                    
                    // Update slider labels active state
                    updateSliderLabels(percentage);
                    
                    // Update trade info
                    updateTradeInfo();
                });
                
                // Function to update active states on slider labels
                function updateSliderLabels(percentage) {
                    // Remove active class from all labels
                    sliderLabels.forEach(label => label.classList.remove('active'));
                    
                    // Determine closest label to activate
                    const labelValues = [0, 25, 50, 75, 100];
                    const closestIndex = labelValues.reduce((prev, curr, index) => 
                        Math.abs(curr - percentage) < Math.abs(labelValues[prev] - percentage) ? index : prev, 0);
                    
                    // Add active class to closest label
                    sliderLabels[closestIndex].classList.add('active');
                }
            }
            
            // Setup Take Profit and Stop Loss percentage badges
            const takeProfitInput = document.getElementById('take_profit');
            const stopLossInput = document.getElementById('stop_loss');
            const tpBadge = document.querySelector('.tp-badge');
            const slBadge = document.querySelector('.sl-badge');
            
            if (takeProfitInput && tpBadge) {
                takeProfitInput.addEventListener('input', function() {
                    if (!currentInstrument.price) return;
                    
                    const tpPrice = parseFloat(this.value) || 0;
                    const currentPrice = currentInstrument.price;
                    const tradeType = document.getElementById('trade_type').value;
                    
                    // Calculate percentage difference
                    let percentDiff = 0;
                    if (tradeType === 'buy') {
                        percentDiff = ((tpPrice - currentPrice) / currentPrice) * 100;
                    } else {
                        percentDiff = ((currentPrice - tpPrice) / currentPrice) * 100;
                    }
                    
                    // Update badge
                    tpBadge.textContent = (percentDiff > 0 ? '+' : '') + percentDiff.toFixed(2) + '%';
                });
            }
            
            if (stopLossInput && slBadge) {
                stopLossInput.addEventListener('input', function() {
                    if (!currentInstrument.price) return;
                    
                    const slPrice = parseFloat(this.value) || 0;
                    const currentPrice = currentInstrument.price;
                    const tradeType = document.getElementById('trade_type').value;
                    
                    // Calculate percentage difference
                    let percentDiff = 0;
                    if (tradeType === 'buy') {
                        percentDiff = ((slPrice - currentPrice) / currentPrice) * 100;
                    } else {
                        percentDiff = ((currentPrice - slPrice) / currentPrice) * 100;
                    }
                    
                    // Update badge
                    slBadge.textContent = (percentDiff > 0 ? '+' : '') + percentDiff.toFixed(2) + '%';
                });
            }
        });
        
        // Update trade type and recalculate TP/SL percentages
        function setTradeType(type) {
            const oldType = document.getElementById('trade_type').value;
            document.getElementById('trade_type').value = type;
            const submitButton = document.getElementById('submit-trade-button');
            if (submitButton) {
                submitButton.textContent = type.toUpperCase();
                submitButton.className = `btn btn-submit-trade btn-${type}`;
            }
            // Update active state of price buttons
            document.querySelector('.btn-sell-price').classList.toggle('active', type === 'sell');
            document.querySelector('.btn-buy-price').classList.toggle('active', type === 'buy');
            
            // If trade type changed, recalculate TP/SL percentages
            if (oldType !== type) {
                const takeProfitInput = document.getElementById('take_profit');
                const stopLossInput = document.getElementById('stop_loss');
                
                if (takeProfitInput && takeProfitInput.value) {
                    takeProfitInput.dispatchEvent(new Event('input'));
                }
                
                if (stopLossInput && stopLossInput.value) {
                    stopLossInput.dispatchEvent(new Event('input'));
                }
            }
        }
        
        function updateTradeInfo() {
            // Calculate and display Margin Impact, Trade Value based on Amount and Price
            const amountInput = document.getElementById('trade_amount');
            const amount = parseFloat(amountInput.value) || 0;
            const price = currentInstrument.price || 0;
            const type = currentInstrument.type;
            let tradeValue = 0;
            let marginImpact = 0;
            const leverage = 50; // Example leverage, make this dynamic later
            
            if (amount > 0 && price > 0) {
                tradeValue = amount * price;
                // Margin calculation depends heavily on asset type and broker rules
                // Simple example: margin = value / leverage
                marginImpact = tradeValue / leverage;
            }
            
            const valuePrecision = 2;
            document.getElementById('trade-value').textContent = `$ ${tradeValue.toFixed(valuePrecision)}`;
            document.getElementById('margin-impact').textContent = `$ ${marginImpact.toFixed(valuePrecision)}`;
            
            // Check if amount exceeds available balance
            const availableBalance = parseFloat("{{ current_user.current_balance }}") || 0;
            const submitButton = document.getElementById('submit-trade-button');
            
            if (marginImpact > availableBalance) {
                // Not enough balance
                if (submitButton) {
                    submitButton.disabled = true;
                    submitButton.classList.add('disabled');
                }
                document.getElementById('margin-impact').classList.add('price-down');
            } else {
                // Sufficient balance
                if (submitButton) {
                    submitButton.disabled = false;
                    submitButton.classList.remove('disabled');
                }
                document.getElementById('margin-impact').classList.remove('price-down');
            }
        }

        // Function to get current leverage
        function getCurrentLeverage() {
            const leverageSelect = document.getElementById('leverage-select');
            if (leverageSelect) {
                return parseFloat(leverageSelect.value) || 5;
            }
            return 5; // Default to 5x leverage
        }

        function updateTradeInfo() {
            try {
                // Get input values
                const amount = parseFloat(document.getElementById('trade_amount').value) || 0;
                const leverage = getCurrentLeverage();
                
                console.log(`Updating trade info - Amount: ${amount}, Leverage: ${leverage}`);
                
                // Get the actual instrument price
                let currentPrice = 0;
                if (currentInstrument && currentInstrument.price) {
                    currentPrice = currentInstrument.price;
                } else {
                    // Try to get from price displays
                    const buyPriceElement = document.getElementById('buy-price-display');
                    if (buyPriceElement && buyPriceElement.textContent) {
                        currentPrice = parseFloat(buyPriceElement.textContent) || 0;
                    }
                }
                
                // Calculate position values
                const positionValue = amount * currentPrice;
                const marginRequired = positionValue / leverage;
                
                console.log(`Position calculations - Price: ${currentPrice}, Value: ${positionValue}, Margin: ${marginRequired}`);
                
                // Update UI displays
                document.getElementById('margin-required-value').textContent = `$${marginRequired.toFixed(2)}`;
                document.getElementById('effective-leverage').textContent = `${leverage}x`;
                document.getElementById('trade-value').textContent = `$${positionValue.toFixed(2)}`;
                
                // Validate against available balance
                const availableBalanceElement = document.getElementById('available-balance');
                const availableBalance = parseFloat(availableBalanceElement ? availableBalanceElement.textContent.replace('$', '') : 0) || 0;
                
                console.log(`Balance check - Available: ${availableBalance}, Required: ${marginRequired}`);
                
                // Update trade button state based on validation
                const isValidTrade = marginRequired <= availableBalance;
                const submitButton = document.getElementById('submit-trade-button');
                
                if (submitButton) {
                    submitButton.disabled = !isValidTrade || amount <= 0;
                    
                    if (!isValidTrade && amount > 0) {
                        submitButton.title = "Insufficient margin available";
                    } else if (amount <= 0) {
                        submitButton.title = "Please enter an amount";
                    } else {
                        submitButton.title = "";
                    }
                }
            } catch (error) {
                console.error("Error updating trade info:", error);
            }
        }

        function executeTrade(direction) {
            const amount = parseFloat(document.getElementById('trade_amount').value);
            const leverage = getCurrentLeverage();
            const currentPrice = currentInstrument.price || parseFloat(document.getElementById('buy-price').textContent) || 0;
            
            if (!amount || amount <= 0) {
                showNotification('Please enter a valid amount', 'error');
                return;
            }
            
            const positionValue = amount * currentPrice;
            const marginRequired = positionValue / leverage;
            const availableBalance = parseFloat(document.getElementById('available-balance').textContent.replace('$', ''));
            
            if (marginRequired > availableBalance) {
                showNotification('Insufficient margin available', 'error');
                return;
            }
            
            // Add leverage to the trade data without affecting the price
            const tradeData = {
                symbol: currentInstrument.symbol,
                amount: amount,
                direction: direction,
                leverage: leverage,
                margin: marginRequired,
                price: currentPrice // Use actual instrument price
            };
            
            // Send trade to server
            fetch('/api/trade', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCsrfToken()
                },
                body: JSON.stringify(tradeData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showNotification(`${direction.toUpperCase()} order executed successfully`, 'success');
                    updateBalance(data.newBalance);
                    loadOpenTrades();
                } else {
                    showNotification(data.error || 'Trade execution failed', 'error');
                }
            })
            .catch(error => {
                console.error('Trade execution error:', error);
                showNotification('Trade execution failed', 'error');
            });
        }

        function updateInstrumentPriceAndUI() {
            if (!currentInstrument.id) return;
            
            fetch(`/webtrader/get_price?instrument_id=${currentInstrument.id}`)
                .then(response => response.json())
                .then(data => {
                    if (data.current_price !== null) {
                        const price = parseFloat(data.current_price);
                        currentInstrument.price = price; // Store the actual price
                        
                        // Format price based on instrument type (without leverage influence)
                        let formattedPrice;
                        if (currentInstrument.type === 'crypto') {
                            if (price >= 1000) {
                                formattedPrice = price.toFixed(2);
                            } else if (price >= 10) {
                                formattedPrice = price.toFixed(3);
                            } else if (price >= 1) {
                                formattedPrice = price.toFixed(4);
                            } else {
                                formattedPrice = price.toFixed(6);
                            }
                        } else if (currentInstrument.type === 'forex') {
                            formattedPrice = price.toFixed(4);
                        } else {
                            formattedPrice = price.toFixed(2);
                        }
                        
                        // Update displays with actual price (not affected by leverage)
                        document.getElementById('current-price').textContent = formattedPrice;
                        
                        // Update Bid/Ask with small spread
                        const spread = price * 0.0002; // 0.02% spread
                        const sellPrice = (price - spread).toFixed(currentInstrument.precision);
                        const buyPrice = (price + spread).toFixed(currentInstrument.precision);
                        
                        document.getElementById('sell-price-display').textContent = sellPrice;
                        document.getElementById('buy-price-display').textContent = buyPrice;
                        
                        // Update trade info with new price
                        updateTradeInfo();
                    }
                })
                .catch(error => console.error('Error fetching instrument price:', error));
        }

        // Add Event Listeners for Trade Form Fields
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listener to amount input
            const amountInput = document.getElementById('trade_amount');
            if (amountInput) {
                amountInput.addEventListener('input', function() {
                    // Update trade info whenever amount changes
                    updateTradeInfo();
                });
            }
            
            // Add event listener to leverage select
            const leverageSelect = document.getElementById('leverage-select');
            if (leverageSelect) {
                leverageSelect.addEventListener('change', function() {
                    // Update trade info whenever leverage changes
                    updateTradeInfo();
                });
            }
            
            // Initialize trade info on page load
            updateTradeInfo();
        });

        // Add listener to amount input for immediate calculation
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Setting up event listeners for trade form");
            
            // Get the amount input
            const amountInput = document.getElementById('trade_amount');
            if (amountInput) {
                // Add input event listener (fires on any change)
                amountInput.addEventListener('input', function() {
                    console.log("Amount changed to:", this.value);
                    // Update trade info whenever amount changes
                    updateTradeInfo();
                });
                
                // Trigger initial calculation with a small delay
                setTimeout(function() {
                    updateTradeInfo();
                }, 500);
            }
            
            // Add change event listener to leverage select
            const leverageSelect = document.getElementById('leverage-select');
            if (leverageSelect) {
                leverageSelect.addEventListener('change', function() {
                    console.log("Leverage changed to:", this.value);
                    // Update trade info whenever leverage changes
                    updateTradeInfo();
                });
            }
        });

        // Make sure margin metrics are calculated and displayed when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Calculate and display initial margin values
            setTimeout(function() {
                updateMarginMetrics();
                
                // Also update trade details if trading panel is visible
                const tradeAmountInput = document.getElementById('trade_amount');
                if (tradeAmountInput) {
                    // Set up event listeners
                    tradeAmountInput.addEventListener('input', function() {
                        updateTradeInfo();
                    });
                    
                    // Initial calculation
                    updateTradeInfo();
                }
                
                // Start periodic updates of margin metrics
                setInterval(updateMarginMetrics, 3000);
            }, 500);
        });

        // Function to calculate and update margin metrics
        function updateMarginMetrics() {
            try {
                // Get user's balance
                const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                
                // Calculate margin used from open trades
                let marginUsed = 0;
                let totalPL = 0;
                const openTradeRows = document.querySelectorAll('.open-trade-row');
                
                console.log("Calculating margin from " + openTradeRows.length + " open trade(s)");
                
                // DIRECT CALCULATION FROM TRADE TABLE
                // We will calculate the exact margin needed based on the actual trade values
                if (openTradeRows.length > 0) {
                    openTradeRows.forEach(row => {
                        try {
                            // Get symbol, amount and price
                            const symbolCell = row.querySelector('td:nth-child(1)');
                            const amountCell = row.querySelector('td:nth-child(2)');
                            const priceCell = row.querySelector('td:nth-child(3)');
                            const typeCell = row.querySelector('td:nth-child(4)');
                            
                            if (symbolCell && amountCell && priceCell) {
                                const symbol = symbolCell.textContent.trim();
                                const amount = parseFloat(amountCell.textContent) || 0;
                                const price = parseFloat(priceCell.textContent) || 0;
                                const tradeType = typeCell ? typeCell.textContent.trim() : 'BUY';
                                
                                // Calculate the full trade value
                                const tradeValue = amount * price;
                                
                                // Get leverage - first try from data attribute, then default to 5x
                                const leverage = parseFloat(row.getAttribute('data-leverage') || '5');
                                
                                // Calculate actual margin - this is the key calculation
                                const tradeMargin = tradeValue / leverage;
                                
                                // Important: We need a minimum threshold so tiny trades don't result in $0.00 margin
                                // For very small trades, use at least $1 margin
                                const finalMargin = tradeMargin < 1 ? 1 : tradeMargin;
                                
                                // Add to overall margin used
                                marginUsed += finalMargin;
                                
                                // Calculate P/L for this trade
                                const plCell = row.querySelector('.profit-loss-cell');
                                if (plCell) {
                                    const tradePL = parseFloat(plCell.textContent) || 0;
                                    totalPL += tradePL;
                                }
                                
                                console.log(`Trade ${symbol}: Amount=${amount}, Price=$${price}, Value=$${tradeValue.toFixed(2)}, Leverage=${leverage}x, Margin=$${finalMargin.toFixed(2)}`);
                            }
                        } catch (err) {
                            console.error("Error processing trade row:", err);
                        }
                    });
                }
                
                // FALLBACK - If margin is still too small, check if we're about to make a trade
                if (marginUsed < 1) {
                    const marginRequiredElement = document.getElementById('margin-required-value');
                    if (marginRequiredElement) {
                        const panelMargin = parseFloat(marginRequiredElement.textContent.replace('$', '')) || 0;
                        if (panelMargin > 0) {
                            marginUsed = panelMargin;
                            console.log(`Using panel margin value: $${panelMargin.toFixed(2)}`);
                        }
                    }
                }
                
                // Calculate equity (balance + unrealized P/L)
                const equity = balance + totalPL;
                
                console.log(`Final calculations: Balance=$${balance.toFixed(2)}, P/L=$${totalPL.toFixed(2)}, Equity=$${equity.toFixed(2)}, Margin Used=$${marginUsed.toFixed(2)}`);
                
                // Update equity display
                document.getElementById('user-equity').textContent = '$' + equity.toFixed(2);
                
                // Calculate free margin (equity - margin used)
                const freeMargin = equity - marginUsed;
                
                // Calculate margin level (equity / margin used) * 100%
                let marginLevel = marginUsed > 0 ? (equity / marginUsed) * 100 : Infinity;
                
                // Cap the margin level display at a reasonable value
                if (marginLevel > 1000000) {
                    marginLevel = Infinity;
                }
                
                // Update UI elements
                document.getElementById('user-margin').textContent = '$' + marginUsed.toFixed(2);
                document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                
                // Format margin level
                let marginLevelText = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
                document.getElementById('user-margin-level').textContent = marginLevelText;
                
                // Add color coding to margin level based on risk
                const marginLevelElement = document.getElementById('user-margin-level');
                if (marginLevel === Infinity || marginLevel > 500) {
                    // Very safe - excellent margin level
                    marginLevelElement.className = 'balance-value price-up';
                } else if (marginLevel > 200) {
                    // Good margin level
                    marginLevelElement.className = 'balance-value price-up';
                } else if (marginLevel > 100) {
                    // Moderate risk
                    marginLevelElement.className = 'balance-value';
                } else if (marginLevel > 50) {
                    // Warning - margin call risk
                    marginLevelElement.className = 'balance-value price-warning';
                } else {
                    // High risk of margin call
                    marginLevelElement.className = 'balance-value price-down';
                }
                
                // Color code free margin if it's getting low
                const freeMarginElement = document.getElementById('user-free-margin');
                if (freeMargin <= 0) {
                    freeMarginElement.className = 'balance-value price-down';
                } else if (freeMargin < balance * 0.1) { // Less than 10% of balance
                    freeMarginElement.className = 'balance-value price-warning';
                } else {
                    freeMarginElement.className = 'balance-value';
                }
            } catch (error) {
                console.error("Error updating margin metrics:", error);
            }
        }

        // Add event listener to update margin when amount changes
        function setupMarginSync() {
            // Get the amount input field
            const amountInput = document.getElementById('trade-amount');
            if (amountInput) {
                // Listen for input changes
                amountInput.addEventListener('input', function() {
                    setTimeout(function() {
                        const marginRequiredElement = document.getElementById('margin-required-value');
                        if (marginRequiredElement) {
                            const marginValue = parseFloat(marginRequiredElement.textContent.replace('$', '')) || 0;
                            if (marginValue > 0) {
                                // Directly update the margin in header
                                document.getElementById('user-margin').textContent = '$' + marginValue.toFixed(2);
                                
                                // Also update free margin
                                const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                                const equity = parseFloat(document.getElementById('user-equity').textContent.replace('$', '')) || balance;
                                const freeMargin = equity - marginValue;
                                document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                                
                                // Calculate margin level
                                let marginLevel = marginValue > 0 ? (balance / marginValue) * 100 : Infinity;
                                if (marginLevel > 1000000) marginLevel = Infinity;
                                
                                // Format and update margin level
                                let marginLevelText = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
                                document.getElementById('user-margin-level').textContent = marginLevelText;
                                
                                console.log(`Synced margin from trade panel: $${marginValue.toFixed(2)}`);
                            }
                        }
                    }, 100); // Small delay to let calculation complete
                });
                console.log("Margin sync event listener set up");
            }
        }

        // Add similar event listener for leverage changes
        function setupLeverageSync() {
            const leverageButtons = document.querySelectorAll('.leverage-option');
            if (leverageButtons.length > 0) {
                leverageButtons.forEach(btn => {
                    btn.addEventListener('click', function() {
                        setTimeout(function() {
                            const marginRequiredElement = document.getElementById('margin-required-value');
                            if (marginRequiredElement) {
                                const marginValue = parseFloat(marginRequiredElement.textContent.replace('$', '')) || 0;
                                if (marginValue > 0) {
                                    document.getElementById('user-margin').textContent = '$' + marginValue.toFixed(2);
                                    
                                    // Update free margin and margin level as well
                                    const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                                    const equity = parseFloat(document.getElementById('user-equity').textContent.replace('$', '')) || balance;
                                    const freeMargin = equity - marginValue;
                                    document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                                    
                                    let marginLevel = marginValue > 0 ? (balance / marginValue) * 100 : Infinity;
                                    if (marginLevel > 1000000) marginLevel = Infinity;
                                    
                                    let marginLevelText = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
                                    document.getElementById('user-margin-level').textContent = marginLevelText;
                                    
                                    console.log(`Synced margin after leverage change: $${marginValue.toFixed(2)}`);
                                }
                            }
                        }, 100);
                    });
                });
                console.log("Leverage change event listeners set up");
            }
        }

        // Call this after page loads to execute trades listener
        document.addEventListener('DOMContentLoaded', function() {
            // Setup initial event listeners
            setupMarginSync();
            setupLeverageSync();
            
            // Also set them up again whenever the instrument changes
            document.addEventListener('instrumentChanged', function() {
                setTimeout(function() {
                    setupMarginSync();
                    setupLeverageSync();
                }, 500); // Give time for new elements to be added
            });
            
            // The original updateMarginMetrics will still run periodically
            // But this gives immediate updates when typing
        });

        // Add this to end of your document ready function or initialization
        document.addEventListener('DOMContentLoaded', function() {
            // ... existing code ...
            
            // Set up a custom event for when instrument changes
            function createInstrumentChangedEvent() {
                return new CustomEvent('instrumentChanged');
            }
            
            // Modify your instrument change handler to dispatch this event
            const originalChangeInstrument = window.changeInstrument;
            if (originalChangeInstrument) {
                window.changeInstrument = function(instrumentId) {
                    originalChangeInstrument(instrumentId);
                    document.dispatchEvent(createInstrumentChangedEvent());
                };
            }
        });

        // Add a global variable to store the last valid margin required value
        let lastValidMarginRequired = 0;

        // Modify the calculateMarginRequired function to store the value
        function calculateMarginRequired() {
            try {
                const amountInput = document.getElementById('trade-amount');
                const amount = parseFloat(amountInput.value) || 0;
                
                const currentPriceElement = document.querySelector('.current-price');
                const currentPrice = parseFloat(currentPriceElement.textContent.replace('$', '')) || 0;
                
                // Get the active leverage
                const activeLeverageButton = document.querySelector('.leverage-option.active');
                const leverage = activeLeverageButton ? parseInt(activeLeverageButton.getAttribute('data-leverage')) : 5;
                
                // Calculate total value
                const totalValue = amount * currentPrice;
                
                // Calculate margin required (account for leverage)
                const marginRequired = totalValue / leverage;
                
                // Store this value globally
                if (marginRequired > 0) {
                    lastValidMarginRequired = marginRequired;
                    console.log("Stored margin required value: $" + marginRequired.toFixed(2));
                }
                
                // Update the value in the UI
                document.getElementById('margin-required-value').textContent = '$' + marginRequired.toFixed(2);
                document.getElementById('value').textContent = '$' + totalValue.toFixed(2);
                
                // Get current used margin from existing trades
                let existingMargin = 0;
                const openTradeRows = document.querySelectorAll('.open-trade-row');
                
                if (openTradeRows.length > 0) {
                    openTradeRows.forEach(row => {
                        try {
                            const amountCell = row.querySelector('td:nth-child(2)');
                            const priceCell = row.querySelector('td:nth-child(3)');
                            
                            if (amountCell && priceCell) {
                                const tradeAmount = parseFloat(amountCell.textContent) || 0;
                                const tradePrice = parseFloat(priceCell.textContent) || 0;
                                const tradeValue = tradeAmount * tradePrice;
                                const tradeLeverage = parseFloat(row.getAttribute('data-leverage') || '5');
                                const tradeMargin = tradeValue / tradeLeverage;
                                existingMargin += Math.max(tradeMargin, 1); // Minimum $1 margin
                            }
                        } catch (err) {
                            console.error("Error calculating existing trade margin:", err);
                        }
                    });
                }
                
                // Calculate total margin (existing + new trade)
                const totalMargin = existingMargin + marginRequired;
                console.log(`Total margin: $${totalMargin.toFixed(2)} (existing: $${existingMargin.toFixed(2)} + new: $${marginRequired.toFixed(2)})`);
                
                // Update the header margin display with TOTAL margin
                document.getElementById('user-margin').textContent = '$' + totalMargin.toFixed(2);
                
                // Update free margin
                const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                const equity = parseFloat(document.getElementById('user-equity').textContent.replace('$', '')) || balance;
                const freeMargin = equity - totalMargin;
                document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                
                // Update margin level - using equity instead of balance and TOTAL margin for the calculation
                let marginLevel = totalMargin > 0 ? (equity / totalMargin) * 100 : Infinity;
                if (marginLevel > 1000000) marginLevel = Infinity;
                const marginLevelText = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
                document.getElementById('user-margin-level').textContent = marginLevelText;
                
                return marginRequired;
            } catch (error) {
                console.error("Error calculating margin:", error);
                return 0;
            }
        }

        // Add a handler for the Buy/Sell buttons to preserve margin during execution
        function setupTradeExecutionHandler() {
            const buyButton = document.querySelector('.buy-button');
            const sellButton = document.querySelector('.sell-button');
            
            if (buyButton) {
                buyButton.addEventListener('click', function() {
                    // Store current margin before trade execution
                    const marginRequiredElement = document.getElementById('margin-required-value');
                    if (marginRequiredElement) {
                        const currentMargin = parseFloat(marginRequiredElement.textContent.replace('$', '')) || 0;
                        if (currentMargin > 0) {
                            lastValidMarginRequired = currentMargin;
                            console.log("Captured margin at trade execution (buy): $" + currentMargin.toFixed(2));
                            
                            // Force update the UI right away
                            document.getElementById('user-margin').textContent = '$' + currentMargin.toFixed(2);
                            
                            // Setup a timer to keep applying this value after the table updates
                            preserveMarginAfterExecution();
                        }
                    }
                });
            }
            
            if (sellButton) {
                sellButton.addEventListener('click', function() {
                    // Store current margin before trade execution
                    const marginRequiredElement = document.getElementById('margin-required-value');
                    if (marginRequiredElement) {
                        const currentMargin = parseFloat(marginRequiredElement.textContent.replace('$', '')) || 0;
                        if (currentMargin > 0) {
                            lastValidMarginRequired = currentMargin;
                            console.log("Captured margin at trade execution (sell): $" + currentMargin.toFixed(2));
                            
                            // Force update the UI right away
                            document.getElementById('user-margin').textContent = '$' + currentMargin.toFixed(2);
                            
                            // Setup a timer to keep applying this value after the table updates
                            preserveMarginAfterExecution();
                        }
                    }
                });
            }
            
            console.log("Trade execution handlers set up");
        }

        // Function to preserve margin after execution by repeatedly applying it
        function preserveMarginAfterExecution() {
            if (lastValidMarginRequired <= 0) {
                return; // No valid margin to preserve
            }
            
            // Apply the stored margin value to the UI immediately
            document.getElementById('user-margin').textContent = '$' + lastValidMarginRequired.toFixed(2);
            
            // Calculate and update related metrics
            const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
            const equity = parseFloat(document.getElementById('user-equity').textContent.replace('$', '')) || balance;
            const freeMargin = equity - lastValidMarginRequired;
            document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
            
            let marginLevel = lastValidMarginRequired > 0 ? (equity / lastValidMarginRequired) * 100 : Infinity;
            if (marginLevel > 1000000) marginLevel = Infinity;
            const marginLevelText = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
            document.getElementById('user-margin-level').textContent = marginLevelText;
            
            console.log("Preserved margin after execution: $" + lastValidMarginRequired.toFixed(2));
            
            // Keep applying this value several times to ensure it persists after any AJAX updates
            let attempts = 0;
            const intervalId = setInterval(function() {
                document.getElementById('user-margin').textContent = '$' + lastValidMarginRequired.toFixed(2);
                document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                document.getElementById('user-margin-level').textContent = marginLevelText;
                
                attempts++;
                if (attempts >= 10) {
                    clearInterval(intervalId);
                }
            }, 500); // Every half second for 5 seconds
        }

        // Add this to your document ready function
        document.addEventListener('DOMContentLoaded', function() {
            // Setup trade execution handlers
            setupTradeExecutionHandler();
            
            // Handle instrument changes
            document.addEventListener('instrumentChanged', function() {
                setTimeout(function() {
                    setupTradeExecutionHandler();
                }, 500);
            });
            
            // Override the existing updateMarginMetrics function to use our stored value
            const originalUpdateMarginMetrics = window.updateMarginMetrics;
            if (originalUpdateMarginMetrics) {
                window.updateMarginMetrics = function() {
                    // If we have a valid stored margin, use it instead
                    if (lastValidMarginRequired > 0) {
                        // Force our value into the UI
                        document.getElementById('user-margin').textContent = '$' + lastValidMarginRequired.toFixed(2);
                        
                        // Calculate related metrics
                        const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                        const equity = parseFloat(document.getElementById('user-equity').textContent.replace('$', '')) || balance;
                        const freeMargin = equity - lastValidMarginRequired;
                        document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                        
                        let marginLevel = lastValidMarginRequired > 0 ? (balance / lastValidMarginRequired) * 100 : Infinity;
                        if (marginLevel > 1000000) marginLevel = Infinity;
                        const marginLevelText = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
                        document.getElementById('user-margin-level').textContent = marginLevelText;
                        
                        return; // Skip original implementation
                    }
                    
                    // Otherwise run the original function
                    originalUpdateMarginMetrics();
                };
            }
        });

        // Fix for trade execution - directly capture and force margin in AJAX call
        function setupTradeExecutionFix() {
            // Create a wrapper for the executeTrade function
            const originalExecuteTrade = window.executeTrade;
            if (originalExecuteTrade) {
                window.executeTrade = function(type) {
                    // Get and store the margin required before executing the trade
                    const marginRequiredElement = document.getElementById('margin-required-value');
                    if (marginRequiredElement) {
                        const marginRequired = parseFloat(marginRequiredElement.textContent.replace('$', '')) || 0;
                        console.log("TRADE EXECUTION - Margin required: $" + marginRequired.toFixed(2));
                        
                        // If we have a valid margin, store it globally and in localStorage
                        if (marginRequired > 0) {
                            lastValidMarginRequired = marginRequired;
                            
                            // Store in localStorage to persist across page reloads
                            localStorage.setItem('lastMarginRequired', marginRequired.toString());
                            
                            // Force immediate update
                            document.getElementById('user-margin').textContent = '$' + marginRequired.toFixed(2);
                            
                            // Calculate and update related values
                            const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                            const equity = parseFloat(document.getElementById('user-equity').textContent.replace('$', '')) || balance;
                            const freeMargin = equity - marginRequired;
                            document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                            
                            let marginLevel = (balance / marginRequired) * 100;
                            if (marginLevel > 1000000) marginLevel = Infinity;
                            const marginLevelText = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
                            document.getElementById('user-margin-level').textContent = marginLevelText;
                            
                            // Schedule repeated updates
                            const intervalId = setInterval(function() {
                                document.getElementById('user-margin').textContent = '$' + marginRequired.toFixed(2);
                                document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                                document.getElementById('user-margin-level').textContent = marginLevelText;
                            }, 100); // Rapid updates
                            
                            // Stop after 10 seconds
                            setTimeout(function() {
                                clearInterval(intervalId);
                            }, 10000);
                        }
                    }
                    
                    // Call original function
                    return originalExecuteTrade(type);
                };
                console.log("Trade execution function wrapped for margin preservation");
            }
        }

        // On document load, set up all trade execution fixes
        document.addEventListener('DOMContentLoaded', function() {
            setupTradeExecutionFix();
            
            // Check for stored margin from localStorage
            const storedMargin = localStorage.getItem('lastMarginRequired');
            if (storedMargin) {
                const marginValue = parseFloat(storedMargin);
                if (marginValue > 0) {
                    lastValidMarginRequired = marginValue;
                    console.log("Restored margin from localStorage: $" + marginValue.toFixed(2));
                    
                    // Force update
                    setTimeout(function() {
                        document.getElementById('user-margin').textContent = '$' + marginValue.toFixed(2);
                        
                        // Update related values
                        const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                        const equity = parseFloat(document.getElementById('user-equity').textContent.replace('$', '')) || balance;
                        const freeMargin = equity - marginValue;
                        document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                        
                        let marginLevel = (balance / marginValue) * 100;
                        if (marginLevel > 1000000) marginLevel = Infinity;
                        const marginLevelText = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
                        document.getElementById('user-margin-level').textContent = marginLevelText;
                    }, 500);
                }
            }
            
            // Also check for any open trades in the table and force margin update
            setTimeout(function() {
                forceMarginFromOpenTrades();
            }, 1000);
        });

        // Function to force margin calculation from open trades
        function forceMarginFromOpenTrades() {
            const openTradeRows = document.querySelectorAll('.open-trade-row');
            if (openTradeRows.length > 0) {
                let totalMargin = 0;
                
                openTradeRows.forEach(row => {
                    try {
                        // Get the amount and price
                        const amountCell = row.querySelector('td:nth-child(2)');
                        const priceCell = row.querySelector('td:nth-child(3)');
                        
                        if (amountCell && priceCell) {
                            const amount = parseFloat(amountCell.textContent) || 0;
                            const price = parseFloat(priceCell.textContent) || 0;
                            
                            // Calculate trade value
                            const tradeValue = amount * price;
                            
                            // Use leverage from row or default to 5x
                            const leverage = parseFloat(row.getAttribute('data-leverage') || '5');
                            
                            // Calculate margin needed
                            const tradeMargin = tradeValue / leverage;
                            
                            // Use minimum margin of 1
                            const finalMargin = Math.max(tradeMargin, 1);
                            totalMargin += finalMargin;
                            
                            console.log(`Forcing margin for trade: Amount=${amount}, Price=${price}, Value=${tradeValue.toFixed(2)}, Margin=${finalMargin.toFixed(2)}`);
                        }
                    } catch (err) {
                        console.error("Error processing trade row for margin:", err);
                    }
                });
                
                // If we found margin, set it in the UI
                if (totalMargin > 0) {
                    // First check if we have a stored margin value that's larger
                    if (lastValidMarginRequired > totalMargin) {
                        totalMargin = lastValidMarginRequired;
                    }
                    
                    // Force update UI with this margin
                    document.getElementById('user-margin').textContent = '$' + totalMargin.toFixed(2);
                    
                    // Update related values
                    const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                    const equity = parseFloat(document.getElementById('user-equity').textContent.replace('$', '')) || balance;
                    const freeMargin = equity - totalMargin;
                    document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                    
                    let marginLevel = (equity / totalMargin) * 100;
                    if (marginLevel > 1000000) marginLevel = Infinity;
                    const marginLevelText = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
                    document.getElementById('user-margin-level').textContent = marginLevelText;
                    
                    console.log(`Forced total margin from trades: $${totalMargin.toFixed(2)}`);
                }
            }
        }

        /************* MARGIN CALCULATION FIX *************/
        // Override the executeTrade function to capture and preserve margin
        let storedMarginAmount = 0;

        // Wait for document to be ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Setting up margin fix hooks...");
            
            // Wait a bit for all scripts to load
            setTimeout(function() {
                // Override the core execute trade function
                if (typeof executeTrade === 'function') {
                    const originalExecuteTrade = window.executeTrade;
                    
                    window.executeTrade = function(type) {
                        console.log("Trade execution initiated, capturing margin...");
                        
                        // Get margin before executing trade
                        const marginRequiredElement = document.getElementById('margin-required-value');
                        if (marginRequiredElement) {
                            const marginValue = parseFloat(marginRequiredElement.textContent.replace('$', '')) || 0;
                            if (marginValue > 0) {
                                console.log("Captured margin: $" + marginValue.toFixed(2));
                                storedMarginAmount = marginValue;
                                
                                // Store in session storage as backup
                                sessionStorage.setItem('webtrader_margin', marginValue.toString());
                                
                                // Force update margin display
                                updateMarginDisplay(marginValue);
                            }
                        }
                        
                        // Execute original function 
                        const result = originalExecuteTrade(type);
                        
                        // Keep forcing margin updates after trade execution
                        if (storedMarginAmount > 0) {
                            // Immediate update
                            updateMarginDisplay(storedMarginAmount);
                            
                            // Schedule frequent updates for the next 5 seconds
                            const intervalId = setInterval(function() {
                                updateMarginDisplay(storedMarginAmount);
                            }, 200); // Every 200ms
                            
                            setTimeout(function() {
                                clearInterval(intervalId);
                                // Final update
                                updateMarginDisplay(storedMarginAmount);
                            }, 5000);
                        }
                        
                        return result;
                    };
                    
                    console.log("Trade execution function successfully wrapped");
                } else {
                    console.warn("executeTrade function not found");
                }
                
                // Also override updateMarginMetrics if it exists
                if (typeof updateMarginMetrics === 'function') {
                    const originalUpdateMargin = window.updateMarginMetrics;
                    
                    window.updateMarginMetrics = function() {
                        // Run original first
                        originalUpdateMargin();
                        
                        // But then override if we have a stored value
                        if (storedMarginAmount > 0) {
                            updateMarginDisplay(storedMarginAmount);
                        }
                    };
                    
                    console.log("Margin metrics function successfully wrapped");
                }
                
                // Check for stored margin value
                const storedMargin = sessionStorage.getItem('webtrader_margin');
                if (storedMargin) {
                    storedMarginAmount = parseFloat(storedMargin) || 0;
                    if (storedMarginAmount > 0) {
                        console.log("Restored stored margin: $" + storedMarginAmount.toFixed(2));
                        updateMarginDisplay(storedMarginAmount);
                    }
                }
                
                // Add direct event listener to the buy and sell buttons
                const buyButton = document.querySelector('.buy-button');
                const sellButton = document.querySelector('.sell-button');
                
                if (buyButton) {
                    buyButton.addEventListener('click', function() {
                        captureAndStoreMargin();
                    });
                }
                
                if (sellButton) {
                    sellButton.addEventListener('click', function() {
                        captureAndStoreMargin();
                    });
                }
                
                console.log("Buy/Sell button listeners added");
                
                // Also observe changes to the trade-amount input
                const tradeAmountInput = document.getElementById('trade-amount');
                if (tradeAmountInput) {
                    tradeAmountInput.addEventListener('input', function() {
                        // Wait for margin calculation to update
                        setTimeout(function() {
                            captureAndStoreMargin();
                        }, 100);
                    });
                    
                    console.log("Trade amount input listener added");
                }
            }, 1000); // Wait 1 second for everything to initialize
        });

        // Helper function to force margin display update
        function updateMarginDisplay(marginValue) {
            try {
                if (marginValue <= 0) return;
                
                // Force update all UI elements
                document.getElementById('user-margin').textContent = '$' + marginValue.toFixed(2);
                
                // Update free margin and margin level
                const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                const equity = parseFloat(document.getElementById('user-equity').textContent.replace('$', '')) || balance;
                const freeMargin = equity - marginValue;
                document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                
                // Calculate and update margin level
                const marginLevel = marginValue > 0 ? (balance / marginValue) * 100 : Infinity;
                const marginLevelText = marginLevel > 1000000 ? 'âˆž%' : marginLevel.toFixed(2) + '%';
                document.getElementById('user-margin-level').textContent = marginLevelText;
                
                console.log("Updated margin display: $" + marginValue.toFixed(2));
            } catch (err) {
                console.error("Error updating margin display:", err);
            }
        }

        // Helper function to capture margin from the panel
        function captureAndStoreMargin() {
            const marginRequiredElement = document.getElementById('margin-required-value');
            if (marginRequiredElement) {
                const marginValue = parseFloat(marginRequiredElement.textContent.replace('$', '')) || 0;
                if (marginValue > 0) {
                    storedMarginAmount = marginValue;
                    sessionStorage.setItem('webtrader_margin', marginValue.toString());
                    console.log("Stored margin value from panel: $" + marginValue.toFixed(2));
                    updateMarginDisplay(marginValue);
                }
            }
        }

        // FINAL MARGIN FIX - Intercept all methods that could reset margin
        // Global variable to store the true margin amount
        let trueMarginAmount = 0;

        // Wait for page to fully load
        window.addEventListener('load', function() {
            // Set up margin preservation system
            setupMarginPreservation();
        });

        function setupMarginPreservation() {
            console.log("Setting up comprehensive margin preservation system");
            
            // 1. Override XMLHttpRequest to intercept AJAX responses
            const originalXHROpen = XMLHttpRequest.prototype.open;
            const originalXHRSend = XMLHttpRequest.prototype.send;
            
            XMLHttpRequest.prototype.open = function() {
                this._url = arguments[1]; // Store the URL
                return originalXHROpen.apply(this, arguments);
            };
            
            XMLHttpRequest.prototype.send = function() {
                const xhr = this;
                
                // Save margin value before any AJAX call
                if (trueMarginAmount > 0) {
                    console.log(`AJAX request starting - Current margin: $${trueMarginAmount.toFixed(2)}`);
                }
                
                // Listen for the response
                this.addEventListener('load', function() {
                    if (this.responseURL && (
                        this.responseURL.includes('/trade/execute') || 
                        this.responseURL.includes('/trade/update'))) {
                        console.log("Intercepted trade AJAX response");
                        
                        // Wait a moment for DOM updates
                        setTimeout(function() {
                            // Force margin value back to stored value
                            if (trueMarginAmount > 0) {
                                forceMarginValue(trueMarginAmount);
                                console.log(`Restored margin after AJAX: $${trueMarginAmount.toFixed(2)}`);
                            }
                        }, 100);
                    }
                });
                
                return originalXHRSend.apply(this, arguments);
            };
            
            // 2. Store margin when amount is entered
            const tradeAmountInput = document.getElementById('trade-amount');
            if (tradeAmountInput) {
                tradeAmountInput.addEventListener('input', function() {
                    // Wait for calculated values to update
                    setTimeout(captureMarginValue, 100);
                });
            }
            
            // 3. Store margin on leverage change
            const leverageOptions = document.querySelectorAll('.leverage-option');
            if (leverageOptions.length) {
                leverageOptions.forEach(option => {
                    option.addEventListener('click', function() {
                        setTimeout(captureMarginValue, 100);
                    });
                });
            }
            
            // 4. Store margin when clicking buy/sell 
            const buyButton = document.querySelector('.buy-button');
            const sellButton = document.querySelector('.sell-button');
            
            if (buyButton) buyButton.addEventListener('click', captureMarginValue);
            if (sellButton) sellButton.addEventListener('click', captureMarginValue);
            
            // 5. Hook into the existing executeTrade function
            if (typeof window.executeTrade === 'function') {
                const originalExecuteTrade = window.executeTrade;
                window.executeTrade = function(type) {
                    captureMarginValue();
                    const result = originalExecuteTrade.apply(this, arguments);
                    
                    // Force updates after trade execution
                    const intervalId = setInterval(function() {
                        if (trueMarginAmount > 0) {
                            forceMarginValue(trueMarginAmount);
                        }
                    }, 200);
                    
                    setTimeout(function() {
                        clearInterval(intervalId);
                        forceMarginValue(trueMarginAmount);
                    }, 5000);
                    
                    return result;
                };
                console.log("Trade execution function hooked");
            }
            
            // 6. Prevent automatic margin recalculation from reverting our value
            // This must be last as it overrides the updateMarginMetrics function
            if (typeof window.updateMarginMetrics === 'function') {
                const originalUpdateMarginMetrics = window.updateMarginMetrics;
                window.updateMarginMetrics = function() {
                    // Get the current margin value before update
                    const currentMarginElement = document.getElementById('user-margin');
                    const currentMargin = parseFloat(currentMarginElement.textContent.replace('$', '')) || 0;
                    
                    // If we have a valid stored margin and what's displayed is 1.00,
                    // it means the system is trying to reset to the wrong value
                    if (trueMarginAmount > 0 && (currentMargin <= 1.0 || Math.abs(currentMargin - trueMarginAmount) > 0.01)) {
                        forceMarginValue(trueMarginAmount);
                        return; // Skip original function entirely
                    }
                    
                    // Call original function
                    originalUpdateMarginMetrics();
                    
                    // Check if the value was changed to something <= $1.00
                    const newMarginElement = document.getElementById('user-margin');
                    const newMargin = parseFloat(newMarginElement.textContent.replace('$', '')) || 0;
                    
                    if (trueMarginAmount > 1.0 && newMargin <= 1.0) {
                        console.log(`Margin was reset to $${newMargin.toFixed(2)}, restoring to $${trueMarginAmount.toFixed(2)}`);
                        forceMarginValue(trueMarginAmount);
                    }
                };
                console.log("Margin metrics function hooked");
            }
        }

        // Function to capture the current margin value from the panel
        function captureMarginValue() {
            const marginRequiredElement = document.getElementById('margin-required-value');
            if (marginRequiredElement) {
                const marginValue = parseFloat(marginRequiredElement.textContent.replace('$', '')) || 0;
                if (marginValue > 0) {
                    console.log(`Captured margin value: $${marginValue.toFixed(2)}`);
                    
                    // Only update if value is greater than 1 (meaningful margin)
                    if (marginValue > 1.0) {
                        trueMarginAmount = marginValue;
                        sessionStorage.setItem('trueMarginValue', marginValue.toString());
                        
                        // Force update UI
                        forceMarginValue(marginValue);
                    }
                }
            }
        }

        // Function to force a specific margin value into the UI
        function forceMarginValue(marginValue) {
            if (marginValue <= 0) return;
            
            // Force update the margin display
            document.getElementById('user-margin').textContent = '$' + marginValue.toFixed(2);
            
            // Update free margin and margin level
            const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
            const equity = parseFloat(document.getElementById('user-equity').textContent.replace('$', '')) || balance;
            const freeMargin = equity - marginValue;
            
            document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
            
            // Calculate and update margin level
            let marginLevel = marginValue > 0 ? (equity / marginValue) * 100 : Infinity;
            let marginLevelText = marginLevel > 1000000 ? 'âˆž%' : marginLevel.toFixed(2) + '%';
            document.getElementById('user-margin-level').textContent = marginLevelText;
        }

        // Restore margin from session storage if available
        document.addEventListener('DOMContentLoaded', function() {
            const storedMargin = sessionStorage.getItem('trueMarginValue');
            if (storedMargin) {
                const marginValue = parseFloat(storedMargin);
                if (marginValue > 1.0) {
                    trueMarginAmount = marginValue;
                    console.log(`Restored margin from session: $${marginValue.toFixed(2)}`);
                    
                    // Apply after a delay to ensure DOM is ready
                    setTimeout(function() {
                        forceMarginValue(marginValue);
                    }, 500);
                }
            }
        });

        // DIRECT MARGIN FIX - Replace core functions to solve margin reset issue
        document.addEventListener('DOMContentLoaded', function() {
            // Wait to ensure all trading scripts are loaded
            setTimeout(function() {
                installCompleteFix();
            }, 1000);
        });

        function installCompleteFix() {
            // CREATE A GLOBAL REGISTRY FOR ALL TRADES WITH CORRECT MARGIN VALUES
            window.tradeMarginRegistry = window.tradeMarginRegistry || {};
            
            // Override executeTrade to directly store required margin in the registry
            if (typeof window.executeTrade === 'function') {
                const originalExecute = window.executeTrade;
                window.executeTrade = function(type) {
                    // 1. Capture all trade data before execution
                    const symbol = document.querySelector('.trading-instrument-name').textContent.trim();
                    const amount = parseFloat(document.getElementById('trade-amount').value) || 0;
                    const marginElement = document.getElementById('margin-required-value');
                    const margin = marginElement ? parseFloat(marginElement.textContent.replace('$', '')) : 0;
                    
                    // Only proceed if we have valid data
                    if (symbol && amount > 0 && margin > 0) {
                        // Create a unique key for this trade based on symbol, amount and timestamp
                        const tradeKey = `${symbol}-${amount}-${Date.now()}`;
                        
                        // Store the margin in our registry with the trade key
                        window.tradeMarginRegistry[tradeKey] = margin;
                        
                        console.log(`CRITICAL: Stored margin ${margin} for trade ${tradeKey}`);
                        
                        // Immediately update UI
                        updateUIWithCorrectMargin();
                        
                        // Set up listeners to update after AJAX completes
                        setupAfterTradeUpdates();
                    }
                    
                    // Call original function
                    return originalExecute.apply(this, arguments);
                };
                console.log("Trade execution function directly overridden to preserve margin");
            }
            
            // COMPLETELY REPLACE the updateMarginMetrics function
            window.originalUpdateMarginMetrics = window.updateMarginMetrics;
            window.updateMarginMetrics = function() {
                try {
                    // Get user's balance
                    const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                    
                    // Calculate P/L from open trades
                    let totalPL = 0;
                    const plCells = document.querySelectorAll('.profit-loss-cell');
                    plCells.forEach(cell => {
                        const pl = parseFloat(cell.textContent) || 0;
                        totalPL += pl;
                    });
                    
                    // Calculate equity
                    const equity = balance + totalPL;
                    
                    // Update equity display
                    document.getElementById('user-equity').textContent = '$' + equity.toFixed(2);
                    
                    // CRITICAL MARGIN CALCULATION FROM REGISTRY
                    let marginUsed = calculateCorrectMargin();
                    
                    // If we have pending margin calculation, use it instead
                    const marginRequiredElement = document.getElementById('margin-required-value');
                    if (marginRequiredElement) {
                        const pendingMargin = parseFloat(marginRequiredElement.textContent.replace('$', '')) || 0;
                        if (pendingMargin > 1) {
                            // If there's a pending trade with substantial margin, use that value
                            console.log(`Using pending margin requirement: $${pendingMargin.toFixed(2)}`);
                            marginUsed = pendingMargin;
                        }
                    }
                    
                    // For safety, if we still have no margin but have open trades, use at least $5
                    const hasOpenTrades = document.querySelectorAll('.open-trade-row').length > 0;
                    if (marginUsed <= 1 && hasOpenTrades) {
                        const amountCell = document.querySelector('.open-trade-row td:nth-child(2)');
                        const priceCell = document.querySelector('.open-trade-row td:nth-child(3)');
                        
                        if (amountCell && priceCell) {
                            const amount = parseFloat(amountCell.textContent) || 0;
                            const price = parseFloat(priceCell.textContent) || 0;
                            
                            // Calculate position value
                            const positionValue = amount * price;
                            
                            // Calculate margin at 5x leverage (typical default)
                            marginUsed = positionValue / 5;
                            
                            // Enforce minimum of $5 for any valid trade
                            marginUsed = Math.max(marginUsed, 5);
                            
                            console.log(`Calculated fallback margin: $${marginUsed.toFixed(2)}`);
                        }
                    }
                    
                    // Calculate free margin and margin level
                    const freeMargin = equity - marginUsed;
                    let marginLevel = marginUsed > 0 ? (equity / marginUsed) * 100 : Infinity;
                    
                    // Cap the margin level display at a reasonable value
                    if (marginLevel > 1000000) {
                        marginLevel = Infinity;
                    }
                    
                    // Update UI elements
                    document.getElementById('user-margin').textContent = '$' + marginUsed.toFixed(2);
                    document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                    
                    // Format margin level
                    let marginLevelText = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
                    document.getElementById('user-margin-level').textContent = marginLevelText;
                    
                    // Add color coding to margin level based on risk
                    const marginLevelElement = document.getElementById('user-margin-level');
                    if (marginLevel === Infinity || marginLevel > 500) {
                        // Very safe - excellent margin level
                        marginLevelElement.className = 'balance-value price-up';
                    } else if (marginLevel > 200) {
                        // Good margin level
                        marginLevelElement.className = 'balance-value price-up';
                    } else if (marginLevel > 100) {
                        // Moderate risk
                        marginLevelElement.className = 'balance-value';
                    } else if (marginLevel > 50) {
                        // Warning - margin call risk
                        marginLevelElement.className = 'balance-value price-warning';
                    } else {
                        // High risk of margin call
                        marginLevelElement.className = 'balance-value price-down';
                    }
                    
                    // Color code free margin if it's getting low
                    const freeMarginElement = document.getElementById('user-free-margin');
                    if (freeMargin <= 0) {
                        freeMarginElement.className = 'balance-value price-down';
                    } else if (freeMargin < balance * 0.1) { // Less than 10% of balance
                        freeMarginElement.className = 'balance-value price-warning';
                    } else {
                        freeMarginElement.className = 'balance-value';
                    }
                    
                    console.log(`Updated metrics: Margin=$${marginUsed.toFixed(2)}, Free=$${freeMargin.toFixed(2)}, Level=${marginLevelText}`);
                    
                } catch (error) {
                    console.error("Error in custom margin calculation:", error);
                    
                    // If our custom calculation fails, fall back to original
                    if (window.originalUpdateMarginMetrics) {
                        window.originalUpdateMarginMetrics();
                    }
                }
            };
            
            // Function to calculate the correct margin from our registry
            function calculateCorrectMargin() {
                let totalMargin = 0;
                
                // Sum all margins from the registry
                for (const key in window.tradeMarginRegistry) {
                    totalMargin += window.tradeMarginRegistry[key];
                }
                
                // If we have open trades but no registry entries, create them
                if (totalMargin === 0) {
                    const openTradeRows = document.querySelectorAll('.open-trade-row');
                    if (openTradeRows.length > 0) {
                        openTradeRows.forEach((row, index) => {
                            try {
                                const symbol = row.querySelector('td:nth-child(1)').textContent.trim();
                                const amount = parseFloat(row.querySelector('td:nth-child(2)').textContent) || 0;
                                const price = parseFloat(row.querySelector('td:nth-child(3)').textContent) || 0;
                                
                                // Calculate trade value
                                const value = amount * price;
                                
                                // Get leverage from the row or default to 5x
                                const leverage = parseFloat(row.getAttribute('data-leverage') || '5');
                                
                                // Calculate proper margin
                                let margin = value / leverage;
                                
                                // Ensure minimum margin value
                                margin = Math.max(margin, 5);
                                
                                // Generate a key for this trade
                                const tradeKey = `${symbol}-${amount}-${index}`;
                                
                                // Store in registry
                                window.tradeMarginRegistry[tradeKey] = margin;
                                
                                console.log(`Added margin $${margin.toFixed(2)} for existing trade ${tradeKey}`);
                                
                                // Add to total
                                totalMargin += margin;
                            } catch (err) {
                                console.error("Error processing trade row:", err);
                            }
                        });
                    }
                }
                
                return totalMargin;
            }
            
            // Function to update UI with correct margin after AJAX requests
            function setupAfterTradeUpdates() {
                const intervalId = setInterval(function() {
                    updateUIWithCorrectMargin();
                }, 200);
                
                setTimeout(function() {
                    clearInterval(intervalId);
                    updateUIWithCorrectMargin();
                }, 3000);
            }
            
            // Function to update UI with the correct margin
            function updateUIWithCorrectMargin() {
                const margin = calculateCorrectMargin();
                if (margin > 0) {
                    document.getElementById('user-margin').textContent = '$' + margin.toFixed(2);
                    
                    // Update related values
                    const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                    const totalPL = 0; // We're not tracking P/L here
                    const equity = balance + totalPL;
                    const freeMargin = equity - margin;
                    
                    document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                    
                    let marginLevel = margin > 0 ? (equity / margin) * 100 : Infinity;
                    if (marginLevel > 1000000) marginLevel = Infinity;
                    
                    const marginLevelText = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
                    document.getElementById('user-margin-level').textContent = marginLevelText;
                }
            }
            
            // Update immediately
            updateUIWithCorrectMargin();
            
            console.log("COMPLETE MARGIN FIX INSTALLED");
        }

        // Watch for DOM updates to detect new trades
        document.addEventListener('DOMContentLoaded', function() {
            // If MutationObserver is available, use it to detect new trades
            if (window.MutationObserver) {
                const tradesTable = document.querySelector('.trades-table tbody');
                if (tradesTable) {
                    const observer = new MutationObserver(function(mutations) {
                        for (const mutation of mutations) {
                            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                                // New trade row may have been added
                                // Update metrics after a slight delay to ensure all data is available
                                setTimeout(function() {
                                    if (window.updateMarginMetrics) {
                                        window.updateMarginMetrics();
                                    }
                                }, 100);
                            }
                        }
                    });
                    
                    observer.observe(tradesTable, { childList: true });
                    console.log("Trade table observer installed");
                }
            }
        });

        // FINAL FIX: Direct manipulation of trade margin
        // Add this before the end of the script tag
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Setting up final margin fix");
            
            // Find the execute trade function and modify it
            let originalExecuteTrade = null;
            
            // Attempt to locate executeTrade function in window scope
            if (typeof window.executeTrade === 'function') {
                originalExecuteTrade = window.executeTrade;
                applyFix();
            } else {
                // Wait a bit in case it's loaded after the DOM
                setTimeout(function() {
                    if (typeof window.executeTrade === 'function') {
                        originalExecuteTrade = window.executeTrade;
                        applyFix(); 
                    } else {
                        console.error("Could not find executeTrade function");
                    }
                }, 2000);
            }
            
            // Direct DOM element observation for Buy/Sell buttons
            // This works even if we can't find the executeTrade function
            const buyButton = document.querySelector('.buy-button');
            const sellButton = document.querySelector('.sell-button');
            
            if (buyButton) {
                buyButton.addEventListener('click', captureAndForceMargin);
            }
            
            if (sellButton) {
                sellButton.addEventListener('click', captureAndForceMargin);
            }
            
            // Main fix application
            function applyFix() {
                // Replace the executeTrade function
                window.executeTrade = function(type) {
                    // Capture margin before trade execution
                    captureAndForceMargin();
                    
                    // Call original function
                    const result = originalExecuteTrade.apply(this, arguments);
                    
                    // Force margin after execution
                    setTimeout(forceMarginUIUpdate, 100);
                    setTimeout(forceMarginUIUpdate, 500);
                    setTimeout(forceMarginUIUpdate, 1000);
                    
                    return result;
                };
                
                console.log("Trade execution function overridden with margin fix");
            }
            
            // Function to capture and force margin
            function captureAndForceMargin() {
                try {
                    // Get the margin-required value
                    const marginRequiredEl = document.getElementById('margin-required-value');
                    
                    if (marginRequiredEl) {
                        const marginValue = parseFloat(marginRequiredEl.textContent.replace('$', '')) || 0;
                        
                        if (marginValue > 0) {
                            console.log("DIRECT: Captured margin value: $" + marginValue.toFixed(2));
                            
                            // Store in localStorage for persistence
                            localStorage.setItem('forcedMarginValue', marginValue.toString());
                            localStorage.setItem('forcedMarginTimestamp', Date.now().toString());
                            
                            // Directly update UI
                            forceMarginUIUpdate(marginValue);
                            
                            // Critical - inject this value into all AJAX requests
                            setupAjaxInterceptors();
                        }
                    }
                } catch (err) {
                    console.error("Error capturing margin:", err);
                }
            }
            
            // Function to force update the UI with correct margin
            function forceMarginUIUpdate(marginValue) {
                // If no value provided, try to get from localStorage
                if (!marginValue) {
                    const storedMargin = localStorage.getItem('forcedMarginValue');
                    if (storedMargin) {
                        marginValue = parseFloat(storedMargin);
                    }
                }
                
                if (!marginValue || marginValue <= 0) return;
                
                // Get existing margin from open trades (excluding the one we're about to add)
                let existingMargin = 0;
                const openTradeRows = document.querySelectorAll('.open-trade-row');
                
                if (openTradeRows.length > 0) {
                    openTradeRows.forEach(row => {
                        try {
                            const amountCell = row.querySelector('td:nth-child(2)');
                            const priceCell = row.querySelector('td:nth-child(3)');
                            
                            if (amountCell && priceCell) {
                                const amount = parseFloat(amountCell.textContent) || 0;
                                const price = parseFloat(priceCell.textContent) || 0;
                                const tradeValue = amount * price;
                                const leverage = parseFloat(row.getAttribute('data-leverage') || '5');
                                const tradeMargin = tradeValue / leverage;
                                existingMargin += Math.max(tradeMargin, 1);
                            }
                        } catch (err) {
                            console.error("Error calculating existing trade margin:", err);
                        }
                    });
                }
                
                // Calculate total margin (existing + new)
                const totalMargin = existingMargin + marginValue;
                console.log(`Total margin: $${totalMargin.toFixed(2)} (existing: $${existingMargin.toFixed(2)} + new: $${marginValue.toFixed(2)})`);
                
                // Direct DOM updates
                document.getElementById('user-margin').textContent = '$' + totalMargin.toFixed(2);
                
                // Update related values
                const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                const equity = parseFloat(document.getElementById('user-equity').textContent.replace('$', '')) || balance;
                
                // Calculate free margin and level
                const freeMargin = equity - totalMargin;
                const marginLevel = (equity / totalMargin) * 100;
                
                // Update UI
                document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                document.getElementById('user-margin-level').textContent = marginLevel.toFixed(2) + '%';
                
                console.log("DIRECT: Forced margin UI update: $" + totalMargin.toFixed(2));
            }
            
            // Set up AJAX interceptors to inject our margin value
            function setupAjaxInterceptors() {
                if (window.XMLHttpRequest.prototype._open) return; // Already set up
                
                // Store original methods
                window.XMLHttpRequest.prototype._open = window.XMLHttpRequest.prototype.open;
                window.XMLHttpRequest.prototype._send = window.XMLHttpRequest.prototype.send;
                
                // Override open to track URL
                window.XMLHttpRequest.prototype.open = function() {
                    this._requestUrl = arguments[1];
                    return this._open.apply(this, arguments);
                };
                
                // Override send to handle trade-related requests
                window.XMLHttpRequest.prototype.send = function() {
                    const xhr = this;
                    const url = this._requestUrl;
                    
                    // Check if this is a trade-related request
                    if (url && (url.includes('/trade') || url.includes('/update'))) {
                        // After response, force our margin
                        this.addEventListener('load', function() {
                            setTimeout(forceMarginUIUpdate, 50);
                            setTimeout(forceMarginUIUpdate, 200);
                        });
                    }
                    
                    return this._send.apply(this, arguments);
                };
                
                console.log("AJAX interceptors set up");
            }
            
            // Set up interval to periodically force UI updates
            // This ensures the margin value stays correct even if something else tries to change it
            let updateInterval = setInterval(function() {
                const storedTimestamp = localStorage.getItem('forcedMarginTimestamp');
                if (storedTimestamp) {
                    const timestamp = parseInt(storedTimestamp);
                    const now = Date.now();
                    
                    // Only keep forcing updates for 5 minutes after the last trade
                    if (now - timestamp < 5 * 60 * 1000) {
                        forceMarginUIUpdate();
                    }
                }
            }, 5000); // Every 5 seconds
            
            // Apply immediately if we have a stored value
            forceMarginUIUpdate();
        });

        // Get the total margin from existing trades plus any new pending trade
        function getTotalMargin(newTradeMargin = 0) {
            let existingMargin = 0;
            
            // First get margin from open trades
            const openTradeRows = document.querySelectorAll('.open-trade-row');
            if (openTradeRows.length > 0) {
                openTradeRows.forEach(row => {
                    try {
                        const amountCell = row.querySelector('td:nth-child(2)');
                        const priceCell = row.querySelector('td:nth-child(3)');
                        
                        if (amountCell && priceCell) {
                            const amount = parseFloat(amountCell.textContent) || 0;
                            const price = parseFloat(priceCell.textContent) || 0;
                            const tradeValue = amount * price;
                            const leverage = parseFloat(row.getAttribute('data-leverage') || '5');
                            const tradeMargin = tradeValue / leverage;
                            existingMargin += Math.max(tradeMargin, 5); // Minimum $5 margin per trade
                        }
                    } catch (err) {
                        console.error("Error calculating trade margin:", err);
                    }
                });
            }
            
            // Add the new trade margin if provided
            const totalMargin = existingMargin + (newTradeMargin > 0 ? newTradeMargin : 0);
            
            // Log this calculation for debugging
            console.log(`Total margin: $${totalMargin.toFixed(2)} (existing: $${existingMargin.toFixed(2)}, new: $${newTradeMargin.toFixed(2)})`);
            
            // Always return at least $5 of margin if we have any trades
            return (totalMargin > 0) ? Math.max(totalMargin, 5) : 0;
        }
        
        // Update all margin UI elements with the given total margin value
        function updateMarginUI(totalMargin) {
            if (totalMargin <= 0) return;
            
            // Get balance and equity
            const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
            const plValue = calculateTotalPL();
            const equity = balance + plValue;
            
            // Calculate free margin and margin level
            const freeMargin = equity - totalMargin;
            let marginLevel = totalMargin > 0 ? (equity / totalMargin) * 100 : Infinity;
            
            // Cap margin level for display
            if (marginLevel > 1000000) marginLevel = Infinity;
            const marginLevelText = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
            
            // Update all UI elements
            document.getElementById('user-margin').textContent = '$' + totalMargin.toFixed(2);
            document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
            document.getElementById('user-margin-level').textContent = marginLevelText;
            document.getElementById('user-equity').textContent = '$' + equity.toFixed(2);
            
            // Add color coding to margin level based on risk
            const marginLevelElement = document.getElementById('user-margin-level');
            if (marginLevel === Infinity || marginLevel > 500) {
                // Very safe - excellent margin level
                marginLevelElement.className = 'balance-value price-up';
            } else if (marginLevel > 200) {
                // Good margin level
                marginLevelElement.className = 'balance-value price-up';
            } else if (marginLevel > 100) {
                // Moderate risk
                marginLevelElement.className = 'balance-value';
            } else if (marginLevel > 50) {
                // Warning - margin call risk
                marginLevelElement.className = 'balance-value price-warning';
            } else {
                // High risk of margin call
                marginLevelElement.className = 'balance-value price-down';
            }
            
            // Color code free margin if it's getting low
            const freeMarginElement = document.getElementById('user-free-margin');
            if (freeMargin <= 0) {
                freeMarginElement.className = 'balance-value price-down';
            } else if (freeMargin < balance * 0.1) { // Less than 10% of balance
                freeMarginElement.className = 'balance-value price-warning';
            } else {
                freeMarginElement.className = 'balance-value';
            }
            
            console.log(`Updated margin UI: Margin=$${totalMargin.toFixed(2)}, Free=$${freeMargin.toFixed(2)}, Level=${marginLevelText}, Equity=$${equity.toFixed(2)}`);
        }
        
        // Helper function to calculate total P/L
        function calculateTotalPL() {
            let totalPL = 0;
            const plCells = document.querySelectorAll('.profit-loss-cell');
            
            plCells.forEach(cell => {
                const pl = parseFloat(cell.textContent) || 0;
                totalPL += pl;
            });
            
            return totalPL;
        }
        
        // Override the main margin calculation function to use our centralized approach
        function calculateMarginRequired() {
            try {
                const amountInput = document.getElementById('trade-amount');
                const amount = parseFloat(amountInput.value) || 0;
                
                const currentPriceElement = document.querySelector('.current-price');
                const currentPrice = parseFloat(currentPriceElement.textContent.replace('$', '')) || 0;
                
                // Get the active leverage
                const activeLeverageButton = document.querySelector('.leverage-option.active');
                const leverage = activeLeverageButton ? parseInt(activeLeverageButton.getAttribute('data-leverage')) : 5;
                
                // Calculate total value
                const totalValue = amount * currentPrice;
                
                // Calculate margin required for this new trade
                const newTradeMargin = totalValue / leverage;
                
                // Store this value for tracking the pending trade
                if (newTradeMargin > 0) {
                    lastValidMarginRequired = newTradeMargin;
                    console.log("New trade margin: $" + newTradeMargin.toFixed(2));
                }
                
                // Update the trade panel UI
                document.getElementById('margin-required-value').textContent = '$' + newTradeMargin.toFixed(2);
                document.getElementById('value').textContent = '$' + totalValue.toFixed(2);
                
                // Get the total margin (existing + new trade)
                const totalMargin = getTotalMargin(newTradeMargin);
                
                // Update all UI elements with the total margin
                updateMarginUI(totalMargin);
                
                return newTradeMargin;
            } catch (error) {
                console.error("Error calculating margin:", error);
                return 0;
            }
        }
        
        // Key function to update all margin metrics - overriding the original
        function updateMarginMetrics() {
            try {
                // Calculate total margin from all open trades
                const totalMargin = getTotalMargin();
                
                // Update all UI elements with this total margin
                updateMarginUI(totalMargin);
            } catch (error) {
                console.error("Error updating margin metrics:", error);
            }
        }
        
        // Override existing forceMarginUIUpdate to use our centralized approach
        function forceMarginUIUpdate(newTradeMargin = 0) {
            // If no new trade margin provided, try to get from localStorage
            if (newTradeMargin <= 0) {
                const storedMargin = localStorage.getItem('forcedMarginValue');
                if (storedMargin) {
                    newTradeMargin = parseFloat(storedMargin);
                }
            }
            
            // Get total margin (existing + new)
            const totalMargin = getTotalMargin(newTradeMargin);
            
            // Update all UI with total margin
            updateMarginUI(totalMargin);
        }
        
        // Install all our margin fixes
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Installing comprehensive margin fixes...");
            
            // Override the global updateMarginMetrics function
            window.updateMarginMetrics = updateMarginMetrics;
            
            // Set up event listeners for trade amount changes
            const amountInput = document.getElementById('trade-amount');
            if (amountInput) {
                amountInput.addEventListener('input', calculateMarginRequired);
            }
            
            // Set up event listeners for leverage changes
            const leverageOptions = document.querySelectorAll('.leverage-option');
            if (leverageOptions.length) {
                leverageOptions.forEach(option => {
                    option.addEventListener('click', function() {
                        setTimeout(calculateMarginRequired, 100);
                    });
                });
            }
            
            // Make sure trade buttons capture and preserve margin
            const buyButton = document.querySelector('.buy-button');
            const sellButton = document.querySelector('.sell-button');
            
            if (buyButton) {
                buyButton.addEventListener('click', function() {
                    // Calculate margin before trade execution
                    const marginValue = calculateMarginRequired();
                    localStorage.setItem('forcedMarginValue', marginValue.toString());
                    
                    // Force recalculation after trade completes
                    setTimeout(forceRecalculateMargin, 1000);
                    setTimeout(forceRecalculateMargin, 2000);
                    setTimeout(forceRecalculateMargin, 3000);
                });
            }
            
            if (sellButton) {
                sellButton.addEventListener('click', function() {
                    // Calculate margin before trade execution
                    const marginValue = calculateMarginRequired();
                    localStorage.setItem('forcedMarginValue', marginValue.toString());
                    
                    // Force recalculation after trade completes
                    setTimeout(forceRecalculateMargin, 1000);
                    setTimeout(forceRecalculateMargin, 2000);
                    setTimeout(forceRecalculateMargin, 3000);
                });
            }
            
            // Initialize margin display
            setTimeout(updateMarginMetrics, 500);
            
            // Set up periodic margin updates
            setInterval(updateMarginMetrics, 3000);
            
            // FINAL DIRECT FIX - observe DOM for trade rows
            setupTradeTableObserver();
            
            // Force initial calculation - this is critical
            setTimeout(forceRecalculateMargin, 1000);
            
            console.log("Margin fixes installed successfully");
        });
        
        // Function to force recalculation of margin when needed
        function forceRecalculateMargin() {
            console.log("FORCING MARGIN RECALCULATION");
            
            // This calculates the direct margin from all open trades
            const openTradeRows = document.querySelectorAll('.open-trade-row');
            let totalMargin = 0;
            let hasOpenTrades = false;
            
            if (openTradeRows.length > 0) {
                hasOpenTrades = true;
                console.log(`Found ${openTradeRows.length} open trades. Calculating total margin...`);
                
                openTradeRows.forEach((row, index) => {
                    try {
                        const symbolCell = row.querySelector('td:nth-child(1)');
                        const amountCell = row.querySelector('td:nth-child(2)');
                        const priceCell = row.querySelector('td:nth-child(3)');
                        
                        if (symbolCell && amountCell && priceCell) {
                            const symbol = symbolCell.textContent.trim();
                            const amount = parseFloat(amountCell.textContent) || 0;
                            const price = parseFloat(priceCell.textContent) || 0;
                            
                            // Get leverage (default to 5 if not found)
                            const leverage = parseFloat(row.getAttribute('data-leverage') || '5');
                            
                            // Calculate full trade value
                            const tradeValue = amount * price;
                            
                            // Calculate margin with proper leverage
                            const tradeMargin = tradeValue / leverage;
                            
                            // Use a minimum of $5 for each trade margin
                            const finalMargin = Math.max(tradeMargin, 5);
                            totalMargin += finalMargin;
                            
                            console.log(`Trade #${index+1}: ${symbol}, Amount=${amount}, Price=${price}, Value=${tradeValue.toFixed(2)}, Leverage=${leverage}x, Margin=${finalMargin.toFixed(2)}`);
                        }
                    } catch (err) {
                        console.error("Error processing trade row:", err);
                    }
                });
            }
            
            // If we have active trades but calculated $0 margin, force a minimum
            if (hasOpenTrades && totalMargin <= 0) {
                totalMargin = 5; // Minimum $5 margin per trade
                console.log("WARNING: Calculated zero margin with open trades. Setting minimum $5 margin.");
            }
            
            // Get balance and calculate equity
            const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
            
            // Calculate P/L
            let totalPL = 0;
            document.querySelectorAll('.profit-loss-cell').forEach(cell => {
                totalPL += parseFloat(cell.textContent) || 0;
            });
            
            // Calculate equity
            const equity = balance + totalPL;
            
            // Calculate free margin
            const freeMargin = equity - totalMargin;
            
            // Calculate margin level
            let marginLevel = totalMargin > 0 ? (equity / totalMargin) * 100 : Infinity;
            if (marginLevel > 1000000) marginLevel = Infinity;
            
            console.log(`FINAL CALCULATION: Total Margin=${totalMargin.toFixed(2)}, Equity=${equity.toFixed(2)}, Free Margin=${freeMargin.toFixed(2)}, Margin Level=${marginLevel === Infinity ? "âˆž" : marginLevel.toFixed(2)}%`);
            
            // Update UI with direct DOM manipulation
            document.getElementById('user-margin').textContent = '$' + totalMargin.toFixed(2);
            document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
            document.getElementById('user-margin-level').textContent = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
            document.getElementById('user-equity').textContent = '$' + equity.toFixed(2);
            
            // Store this value for future checks
            localStorage.setItem('calculatedMargin', totalMargin.toString());
            localStorage.setItem('lastCalculationTime', Date.now().toString());
            
            return totalMargin;
        }
        
        // Set up a DOM observer to detect when trades are added/removed
        function setupTradeTableObserver() {
            // Find the trades table
            const tradesTable = document.querySelector('.trades-table tbody');
            if (!tradesTable) {
                console.log("Trades table not found. Will try again later.");
                setTimeout(setupTradeTableObserver, 1000);
                return;
            }
            
            console.log("Setting up observer for trades table.");
            
            // Use MutationObserver to watch for changes
            const observer = new MutationObserver(function(mutations) {
                let shouldRecalculate = false;
                
                for (const mutation of mutations) {
                    if (mutation.type === 'childList') {
                        shouldRecalculate = true;
                        break;
                    }
                }
                
                if (shouldRecalculate) {
                    console.log("Detected change in trade table. Recalculating margin...");
                    setTimeout(forceRecalculateMargin, 200);
                }
            });
            
            // Start observing
            observer.observe(tradesTable, { 
                childList: true,
                subtree: true
            });
            
            console.log("Trade table observer is now active.");
        }
        
        // Safety check - periodically verify our margin calculation
        setInterval(function() {
            // Get current displayed margin
            const displayedMargin = parseFloat(document.getElementById('user-margin').textContent.replace('$', '')) || 0;
            
            // Get our last calculated margin
            const savedMargin = parseFloat(localStorage.getItem('calculatedMargin')) || 0;
            const lastCalcTime = parseInt(localStorage.getItem('lastCalculationTime')) || 0;
            
            // If it's been more than 10 seconds since last calculation
            const now = Date.now();
            if (now - lastCalcTime > 10000) {
                // Force a recalculation to be safe
                forceRecalculateMargin();
                return;
            }
            
            // If displayed margin is suspicious (too low with open trades or very different from calculated)
            if (
                (document.querySelectorAll('.open-trade-row').length > 0 && displayedMargin < 5) || 
                (savedMargin > 0 && Math.abs(displayedMargin - savedMargin) / savedMargin > 0.1)
            ) {
                console.log(`Margin display mismatch detected. Displayed: $${displayedMargin}, Calculated: $${savedMargin}`);
                forceRecalculateMargin();
            }
        }, 5000); // Check every 5 seconds

        // Function to force margin calculation from open trades
        function forceMarginFromOpenTrades() {
            const openTradeRows = document.querySelectorAll('.open-trade-row');
            if (openTradeRows.length > 0) {
                let totalMargin = 0;
                
                openTradeRows.forEach(row => {
                    try {
                        // Get the amount and price
                        const amountCell = row.querySelector('td:nth-child(2)');
                        const priceCell = row.querySelector('td:nth-child(3)');
                        
                        if (amountCell && priceCell) {
                            const amount = parseFloat(amountCell.textContent) || 0;
                            const price = parseFloat(priceCell.textContent) || 0;
                            
                            // Calculate trade value
                            const tradeValue = amount * price;
                            
                            // Use leverage from row or default to 5x
                            const leverage = parseFloat(row.getAttribute('data-leverage') || '5');
                            
                            // Calculate margin needed
                            const tradeMargin = tradeValue / leverage;
                            
                            // Use minimum margin of 1
                            const finalMargin = Math.max(tradeMargin, 1);
                            totalMargin += finalMargin;
                            
                            console.log(`Forcing margin for trade: Amount=${amount}, Price=${price}, Value=${tradeValue.toFixed(2)}, Margin=${finalMargin.toFixed(2)}`);
                        }
                    } catch (err) {
                        console.error("Error processing trade row for margin:", err);
                    }
                });
                
                // If we found margin, set it in the UI
                if (totalMargin > 0) {
                    // First check if we have a stored margin value that's larger
                    if (lastValidMarginRequired > totalMargin) {
                        totalMargin = lastValidMarginRequired;
                    }
                    
                    // Force update UI with this margin
                    document.getElementById('user-margin').textContent = '$' + totalMargin.toFixed(2);
                    
                    // Update related values
                    const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                    const equity = parseFloat(document.getElementById('user-equity').textContent.replace('$', '')) || balance;
                    const freeMargin = equity - totalMargin;
                    document.getElementById('user-free-margin').textContent = '$' + freeMargin.toFixed(2);
                    
                    let marginLevel = (equity / totalMargin) * 100;
                    if (marginLevel > 1000000) marginLevel = Infinity;
                    const marginLevelText = marginLevel === Infinity ? 'âˆž%' : marginLevel.toFixed(2) + '%';
                    document.getElementById('user-margin-level').textContent = marginLevelText;
                    
                    console.log(`Forced total margin from trades: $${totalMargin.toFixed(2)}`);
                }
            }
        }

        // Run the margin calculation periodically to ensure it's always correct
        document.addEventListener('DOMContentLoaded', function() {
            // Initial calculation after the page loads
            setTimeout(forceMarginFromOpenTrades, 1000);
            
            // Set up periodic recalculation
            setInterval(forceMarginFromOpenTrades, 5000);
            
            // Add observer for trade table changes
            const tradesTable = document.querySelector('.trades-table tbody');
            if (tradesTable && window.MutationObserver) {
                const observer = new MutationObserver(function(mutations) {
                    setTimeout(forceMarginFromOpenTrades, 500);
                });
                
                observer.observe(tradesTable, { 
                    childList: true,
                    subtree: true 
                });
                console.log("Trade table observer set up");
            }
        });

        // FINAL EMERGENCY FIX - Override ALL margin calculations
        document.addEventListener('DOMContentLoaded', function() {
            console.log("*** EMERGENCY MARGIN FIX INSTALLED ***");
            
            // Completely replace the original updateMarginMetrics function
            window.updateMarginMetrics = emergencyMarginFix;
            
            // Add an immediate execution and recurring timer
            setTimeout(emergencyMarginFix, 1000);
            setInterval(emergencyMarginFix, 3000);
            
            // Also inject our fix after any AJAX call completes
            (function(open) {
                XMLHttpRequest.prototype.open = function() {
                    this.addEventListener("load", function() {
                        setTimeout(emergencyMarginFix, 500);
                    });
                    open.apply(this, arguments);
                };
            })(XMLHttpRequest.prototype.open);
            
            // Add trade button interceptors to ensure margin is correct after trade
            const buyButton = document.querySelector('.buy-button');
            const sellButton = document.querySelector('.sell-button');
            
            if (buyButton) {
                buyButton.addEventListener('click', function() {
                    setTimeout(emergencyMarginFix, 1000);
                    setTimeout(emergencyMarginFix, 2000);
                    setTimeout(emergencyMarginFix, 3000);
                });
            }
            
            if (sellButton) {
                sellButton.addEventListener('click', function() {
                    setTimeout(emergencyMarginFix, 1000);
                    setTimeout(emergencyMarginFix, 2000);
                    setTimeout(emergencyMarginFix, 3000);
                });
            }
            
            // Watch for changes in the trade table
            const tradesTable = document.querySelector('.trades-table tbody');
            if (tradesTable && window.MutationObserver) {
                const observer = new MutationObserver(function() {
                    setTimeout(emergencyMarginFix, 500);
                });
                
                observer.observe(tradesTable, { childList: true, subtree: true });
            }
        });
        
        // The single, definitive margin calculation function
        function emergencyMarginFix() {
            try {
                console.log("EMERGENCY MARGIN FIX RUNNING");
                
                // 1. Calculate total margin from all open trades
                const openTradeRows = document.querySelectorAll('.open-trade-row');
                let totalMargin = 0;
                let hasOpenTrades = false;
                
                if (openTradeRows.length > 0) {
                    hasOpenTrades = true;
                    console.log(`Found ${openTradeRows.length} open trade(s)`);
                    
                    openTradeRows.forEach((row, index) => {
                        try {
                            // Get essential trade data
                            const symbolCell = row.querySelector('td:nth-child(1)');
                            const amountCell = row.querySelector('td:nth-child(2)');
                            const priceCell = row.querySelector('td:nth-child(3)');
                            
                            if (symbolCell && amountCell && priceCell) {
                                const symbol = symbolCell.textContent.trim();
                                const amount = parseFloat(amountCell.textContent) || 0;
                                const price = parseFloat(priceCell.textContent) || 0;
                                
                                // Get leverage (default 5x if not found)
                                const leverage = parseFloat(row.getAttribute('data-leverage') || '5');
                                
                                // Calculate the full value of this position
                                const tradeValue = amount * price;
                                
                                // Calculate margin according to leverage
                                const tradeMargin = tradeValue / leverage;
                                
                                // Enforce minimum margin per trade
                                const finalMargin = Math.max(tradeMargin, 5); // Minimum $5 per trade
                                totalMargin += finalMargin;
                                
                                console.log(`Trade ${symbol}: Amount=${amount}, Price=$${price}, Value=$${tradeValue.toFixed(2)}, Leverage=${leverage}x, Margin=$${finalMargin.toFixed(2)}`);
                            }
                        } catch (err) {
                            console.error(`Error processing trade row ${index}:`, err);
                        }
                    });
                    
                    // Store the calculated margin
                    localStorage.setItem('calculated_margin', totalMargin.toString());
                }
                
                // If we have open trades but somehow calculated 0 margin, force a minimum
                if (hasOpenTrades && totalMargin <= 0) {
                    totalMargin = 5; // Minimum $5 per trade
                    console.log("WARNING: Calculated zero margin despite having open trades. Using minimum $5.");
                }
                
                // 2. Get balance
                const balance = parseFloat(document.getElementById('user-balance').textContent.replace('$', '')) || 0;
                
                // 3. Calculate total P/L
                let totalPL = 0;
                document.querySelectorAll('.profit-loss-cell').forEach(cell => {
                    const pl = parseFloat(cell.textContent) || 0;
                    totalPL += pl;
                });
                
                // 4. Calculate equity
                const equity = balance + totalPL;
                
                // 5. Calculate free margin
                const freeMargin = equity - totalMargin;
                
                // 6. Calculate margin level
                let marginLevel = totalMargin > 0 ? (equity / totalMargin) * 100 : 0;
                
                // For display purposes, cap very high values or handle division by zero
                if (totalMargin === 0 || marginLevel > 1000000) {
                    marginLevel = totalMargin === 0 ? 0 : 999999;
                }
                
                // 7. Format display values
                const totalMarginStr = '$' + totalMargin.toFixed(2);
                const freeMarginStr = '$' + freeMargin.toFixed(2);
                const marginLevelStr = marginLevel === 0 ? '0.00%' : marginLevel.toFixed(2) + '%';
                const equityStr = '$' + equity.toFixed(2);
                
                console.log(`FINAL VALUES: Margin=${totalMarginStr}, Free Margin=${freeMarginStr}, Equity=${equityStr}, Margin Level=${marginLevelStr}`);
                
                // 8. Update the UI directly
                document.getElementById('user-margin').textContent = totalMarginStr;
                document.getElementById('user-free-margin').textContent = freeMarginStr;
                document.getElementById('user-margin-level').textContent = marginLevelStr;
                document.getElementById('user-equity').textContent = equityStr;
                
                // 9. Apply color-coding based on margin level
                const marginLevelElement = document.getElementById('user-margin-level');
                if (marginLevel > 500) {
                    marginLevelElement.className = 'balance-value price-up'; // Very safe
                } else if (marginLevel > 200) {
                    marginLevelElement.className = 'balance-value price-up'; // Good
                } else if (marginLevel > 100) {
                    marginLevelElement.className = 'balance-value'; // Moderate
                } else if (marginLevel > 50) {
                    marginLevelElement.className = 'balance-value price-warning'; // Warning
                } else {
                    marginLevelElement.className = 'balance-value price-down'; // High risk
                }
                
                return true;
            } catch (error) {
                console.error("ERROR IN EMERGENCY MARGIN FIX:", error);
                return false;
            }
        }
</script>
</body>
</html>

